% BSD 3-Clause License (LICENSE.txt)
% Copyright (c) 2019, Joonas T. Holmi (jtholmi@gmail.com)
% All rights reserved.

% Repeating patterns in Video Stitching images often result from the
% Video Image view quality issues. The Video Image response is extracted by
% minimizing the local variance. This algorithm heavily relies on the
% iterative and robust clever-variance-based outlier detection scheme by
% G. Buzzi-Ferraris and F. Manenti (2011), 'Outlier detection in large data
% sets', http://dx.doi.org/10.1016/j.compchemeng.2010.11.004. For more
% information, see 'clever_statistics_and_outliers.m'.
    
% This algorithm utilizes the behaviour of the WITec software's Video
% Stitching feature that apparently stitches same-sized squares (in px)
% together with ~5% overlaps. The pattern is changed near the last column
% and row.
    
% This algorithm is best suited for Video Stitching images with
% '(High Resolution)'-tag, which have not been down-scaled (unless the
% original image was bigger than exactly 64 million pixels) and consist of
% integer sized squares. Video Stitching images without '(High Resolution)'
% -tag are always down-scaled to 1024^2 = 1048576 pixels (nearest below).

% ASSUMPTIONS:
% (1) Video Stitching image, I is not truncated or modified in any way.
% (2) Video Stitching image, I was generated by WITec software.
% (3) Video Stitching image, I was generated using a 5% overlap. Override
% this by providing an extra argument '-OverlapRatio' and a new value.

% NOTEWORTHY:
% (1) Huge stitchings may be automatically DOWN-SCALED even if saved in
% High Resolution mode.

% WARNINGS: On down-scaling if 64 million pixels or 1048576 pixels.

% ERRORS:
% (1) N_SI_XY must be a vector of length 2!
% (2) Number of Stitching Images X and Y must both be >= 3!

% INPUTS:
% (1) I: Preferably the WITec software's Video Stitching image.
% (2) N_SI_XY: Any 1-by-2 row vector, where the 1st and the 2nd value
% represent Number of Stitching Images X and Y, respectively.
% (3-Inf) varargin: The 1st input (if not a dashed string extra argument
% listed below) is interpreted as 'N_test', which determines the pattern
% square side length(s), which are to be tested.

% OUTPUTS:
% (1) I_best: The best solution with the least amount of patterns.
% (2) N_best: The best side length of the pattern square.
% (3) cropIndices: [ind1_Begin, ind1_End, ind2_Begin, ind2_End], which
% determines the cropped region indices in the original image I.

% OPTIONAL EXTRA ARGUMENTS (case-insensitive):
% '-Debug': Shows the debug plots that help to follow the procedure
% '-Crop': Crop out the less reliable edge regions from the final result.
% '-Flat': Used for visually flat images and involves less computing.
% '-BestContinuity': Used for visually strongly varying images in order to
% preserve the pattern-to-pattern continuity. However, this may not work if
% the reference region is filled with outliers.
% '-Outliers': Boolean map to mark outliers in the image.
% '-RestoreTooBright': Does not modify too bright (=max intensity) regions.
% '-TrueBlackColor': Provide [R G B] if the camera has a known dark level.
% '-MinSigmasThreshold' (= 2 by default): Try from 2 to 4. The smaller the
% value, the more image data is interpreted as outliers and vice versa.
% This free-parameter is used by 'clever_statistics_and_outliers.m'.
% Increasing this will decrease the cpu time.
% '-UseMedian': Uses (clever) median instead of (clever) mean.
% '-RollingWindowAnalysis': Uses 3-by-3 kernel to improve the outlier
% detection. Try only if the final result is not satisfying.
% '-GlobalRollingWindowAnalysis': Preconditions the original image with a
% 3-by-3 (clever) mean/median kernel to improve the outlier detection.
% '-AdditiveMode': Does corrections in linear space instead of logarithmic.
% '-DisableAutoIgnoreChannels': Disables automatic color channel analysis,
% whether they are mostly (>50%) black (= zero) or not.
% '-IgnoreChannels': Ignores the specified color channels.
% '-LocalWindowSize' (= 17 by default): Used to window-filtering of std
% during the local variance minimization procedure. The number should be an
% odd integer.
% '-OverlapRatio' (= 0.05 by default): Overlap ratio for the stitching.
% '-LowResMaxPixels' (= 1024^2 by default): Low resolution image max size.
% '-HighResMaxPixels' (= 64e6 by default): High resolution image max size.
function [I_best, N_best, cropIndices] = unpattern_video_stitching_helper(I, N_SI_XY, varargin),
    % Correction is done in the logarithmic space, because the pattern is a
    % multiplicative error, not an additive error. This is reasonable by
    % realizing that camera CCD response variation and all the losses along
    % the optical path from the light source to the camera are
    % multiplicative in nature. After all, camera CCD counts are assumed to
    % be nearly linearly dependent on the incoming light power.
    
    % Main findings regarding the Video Stitching feature:
    % (0) The motorized stage performs some additional movements before,
    % during and after the stitching procedure, perhaps for stability.
    % (1) During the procedure, the motorized stage makes constant steps
    % (in px but not in µm due to the stage's step size of i.e. 100 nm).
    % (2) Each captured Video Image is truncated to a constant square (in
    % px), discarding the less-reliable edge regions. The down-scaling (if
    % requested by the WITec software) is then apparently done here.
    % (3) Each resulting square is then linearly weighted from 0 to 1 at 
    % the overlap regions and summed together to obtain the final stiching
    % result. It would seem that no interpolation is used to account for
    % the subpixel displacements.
    % (4) Additional down-scaling is done for pictures which are not saved
    % in High Resolution mode.
    
    S = size(I);
    W = S(1); % Image width
    H = S(2); % Image height
    D = S(3); % Image depth or number of channels
    
    % Testing and reshaping N_SI_XY
    if numel(N_SI_XY) ~= 2, error('N_SI_XY must be a vector of length 2!'); end
    N_SI_XY = reshape(N_SI_XY, 1, []); % Force to a 1-by-2 row vector
    
    %% Parsing the varargin
    
    % Parse varargin before any dashed str
    out = WITio.fun.varargin_dashed_str.removed('', varargin);
    N_test = [];
    if numel(out) > 0, N_test = out{1}; end
    
    % Parse varargin input
    RestoreTooBright = WITio.fun.varargin_dashed_str.exists('RestoreTooBright', varargin); % By default, do not restore too bright
    IsFlat = WITio.fun.varargin_dashed_str.exists('Flat', varargin); % By default, do not assume flatness
    AdditiveMode = WITio.fun.varargin_dashed_str.exists('AdditiveMode', varargin); % By default, fix in a multiplicative mode
    UseMedian = WITio.fun.varargin_dashed_str.exists('UseMedian', varargin); % By default, use mean values
    RollingWindowAnalysis = WITio.fun.varargin_dashed_str.exists('RollingWindowAnalysis', varargin); % By default, smoothen the image
    GlobalRollingWindowAnalysis = WITio.fun.varargin_dashed_str.exists('GlobalRollingWindowAnalysis', varargin); % By default, smoothen the image
    CropEdgePatterns = WITio.fun.varargin_dashed_str.exists('Crop', varargin); % By default, do not crop the image
    AutoIgnoreChannels = ~WITio.fun.varargin_dashed_str.exists('DisableAutoIgnoreChannels', varargin); % By default, automatically ignore channels that have 50% too dark or too bright in the image
    NoReferences = ~WITio.fun.varargin_dashed_str.exists('BestContinuity', varargin); % By default, do not use references to improve the pattern-to-pattern continuity
    Debug = WITio.fun.varargin_dashed_str.exists('Debug', varargin); % By default, do not show Debug visuals
    
%     EdgePatterns = ~WITio.fun.varargin_dashed_str.exists('DisableEdgePatterns', varargin); % By default, enable edge patterns
% '-DisableEdgePatterns': Disables the edge pattern calculations. Can be
% provided with [left, right, top, bottom] input for customization.

    % Check if Outliers was specified
    datas = WITio.fun.varargin_dashed_str.datas('Outliers', varargin, -1);
    B_Outliers = false(W, H);
    if numel(datas) > 0, B_Outliers = datas{1}; end

    % Check if MinSigmasThreshold was specified
    datas = WITio.fun.varargin_dashed_str.datas('MinSigmasThreshold', varargin, -1);
    MinSigmasThreshold = 2; % 2.25 % Too low (<~2) begins to label true data as outliers but too high (>~4) is contaminated by outliers
    if numel(datas) > 0, MinSigmasThreshold = datas{1}; end
    
    % Check if TrueBlackColor was specified
    datas = WITio.fun.varargin_dashed_str.datas('TrueBlackColor', varargin, -1);
    TrueBlackColor = 0;
    if numel(datas) > 0, TrueBlackColor = datas{1}; end
    TrueBlackColor = reshape(TrueBlackColor, 1, 1, []); % Enforce correct shape
    
    % Check if LocalWindowSize was specified
    datas = WITio.fun.varargin_dashed_str.datas('LocalWindowSize', varargin, -1);
    LocalWindowSize = 17;
    if numel(datas) > 0, LocalWindowSize = datas{1}; end
    
    % Check if OverlapRatio was specified
    datas = WITio.fun.varargin_dashed_str.datas('OverlapRatio', varargin, -1);
    OverlapRatio = 0.05; % Interpreted from experimental data
    if numel(datas) > 0, OverlapRatio = datas{1}; end
    
    % Check if LowResMaxPixels was specified
    datas = WITio.fun.varargin_dashed_str.datas('LowResMaxPixels', varargin, -1);
    LowResMaxPixels = 1024.^2; % Interpreted from experimental data
    if numel(datas) > 0, LowResMaxPixels = datas{1}; end
    
    % Check if HighResMaxPixels was specified
    datas = WITio.fun.varargin_dashed_str.datas('HighResMaxPixels', varargin, -1);
    HighResMaxPixels = 64e6; % Interpreted from experimental data
    if numel(datas) > 0, HighResMaxPixels = datas{1}; end
    
    % Check if IgnoreChannels was specified
    datas = WITio.fun.varargin_dashed_str.datas('IgnoreChannels', varargin, -1);
    IgnoreChannels = [];
    if numel(datas) > 0, IgnoreChannels = datas{1}; end
    if numel(IgnoreChannels) == 1, IgnoreChannels = repmat(IgnoreChannels, [1 D]); end
    
    %% Preparation
    
    % Treat too bright regions as outliers
    try, I_max = intmax(class(I)); % Only for an integer type image
    catch, I_max = 1.0; end % For single and double type image
    B_too_bright = I >= I_max;
    if RestoreTooBright, I_too_bright = I(B_too_bright); end
    
    % Automatically ignore all channels that have less than 50% useful data
    if AutoIgnoreChannels && isempty(IgnoreChannels),
        B_too_dark = I <= 0;
        IgnoreChannels = [false false false];
        IgnoreChannels(sum(sum(B_too_dark | B_too_bright, 1), 2) > W.*H./2) = true;
    end
    
    % Detect possible Low and High Resolution down-scalings and warn about them
    N_LR_max = LowResMaxPixels; % Low Resolution maximum amount of pixels
    if ((W-1)*H < N_LR_max || W*(H-1) < N_LR_max) && ((W+1)*H > N_LR_max || W*(H+1) > N_LR_max),
        warning('Video Stitching image may be down-scaled due to Low Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_LR_max);
    end
    N_HR_max = HighResMaxPixels; % High Resolution maximum amount of pixels
    if (W+1)*H > N_HR_max || W*(H+1) > N_HR_max,
        warning('Video Stitching image may be down-scaled due to High Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_HR_max);
    end
    
    N_SI_XY_CF = OverlapRatio/(1-OverlapRatio); % A correction factor derived below
%     if ~EdgePatterns, N_SI_XY_CF = 0; end % Disable edge patterns
    if isempty(N_test),
        % Find lower and upper bounds that produce same amount of N_SI_XY
        
        % Systematic derivation (only in x-direction but equivalent in y-direction):
        % Number of patterns, NW (KNOWN CONSTANT!)
        % Pattern overlap (ratio from 0 to 1), O (UNCERTAIN CONSTANT!)
        % Pattern width, W (TO BE SOLVED!)
        % Pattern width (without overlap), w = (1-O)*W (TO BE SOLVED!)
        % Pattern overlap dW = W-w = w/(1-O) - w = w * O/(1-O)
        % Image width, IW = NW*W-(NW-2)*dW = NW*w + 2*dW (lower bound) % DOUBLE-CHECKED!
        % Image width, IW = (NW-1)*W-(NW-2)*dW = (NW-1)*w + dW (upper bound) % DOUBLE-CHECKED!
        % Inner square width, w = (IW-2*dW)/NW = (IW-2*w*O/(1-O))/NW => IW/(NW+2*O/(1-O)) = IW/(NW+2*CF) (lower bound)
        % Inner square width, w = (IW-dW)/(NW-1) = (IW-w*O/(1-O))/(NW-1) => IW/(NW-1+O/(1-O)) = IW/(NW-1+CF) (upper bound)
        % Correction factor, CF = O/(1-O)
        
        N_lower = max(ceil(S(1:2)./(N_SI_XY + 2.*N_SI_XY_CF)));
        N_upper = min(floor(S(1:2)./(N_SI_XY-1 + N_SI_XY_CF)));
        
        N_test = N_lower:N_upper;
    else,
        N_lower = min(N_test);
        N_upper = max(N_test);
    end
    N_test = N_test(:); % Force to column vector
    
    % Abort if no working solution can exist
    if isempty(N_test),
        warning('No working solution can exist!');
        I_best = I;
        N_best = NaN;
        cropIndices = [];
        return;
    end
    
    % Calculate the overlap, the stitch, and the no-stitch sizes
    N_overlap = round(N_test.*N_SI_XY_CF); % Rounded to nearest integer
    N_stitch = N_test + N_overlap;
    N_nostitch = N_test - N_overlap;
    
    % Override the original N_SI_XY by a reduced number and test the result
    N_SI_XY = floor(bsxfun(@rdivide, bsxfun(@minus, S(1:2), N_overlap+N_stitch), N_test));
    max_N_SI_XY = max(N_SI_XY, [], 1); % Max instead of min to allow some lower quality results to be tested
    
    if max_N_SI_XY(1) <= 2 || max_N_SI_XY(2) <= 2,
        error('Number of Stitching Images X (= %d) and Y (= %d) must both be 3 or more!', max_N_SI_XY(1), max_N_SI_XY(2));
    end
    
    % Construct widths of the edge patterns
    W_edges = [N_overlap N_stitch N_overlap N_stitch]; % Left Right Top Bottom
%     if ~EdgePatterns, W_edges(:,:) = 0; end % Disable edge patterns
    
    % Construct shared indices
    inds1_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,1)+1 W-W_edges(:,2)+1]; % Left Middle Right
    inds1_shared_end = [W_edges(:,1) W-W_edges(:,2) repmat(W, [size(W_edges, 1) 1])]; % Left Middle Right
    inds2_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,3)+1 H-W_edges(:,4)+1]; % Top Middle Bottom
    inds2_shared_end = [W_edges(:,3) H-W_edges(:,4) repmat(H, [size(W_edges, 1) 1])]; % Top Middle Bottom
    
    % Construct indices for all possible patterns
    inds1_begin = [ ...
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds1_end = [ ...
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_begin = [ ...
        inds2_shared_begin(:,1) inds2_shared_begin(:,1) inds2_shared_begin(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_begin(:,2) inds2_shared_begin(:,2) inds2_shared_begin(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_begin(:,3) inds2_shared_begin(:,3) inds2_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_end = [ ...
        inds2_shared_end(:,1) inds2_shared_end(:,1) inds2_shared_end(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_end(:,2) inds2_shared_end(:,2) inds2_shared_end(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_end(:,3) inds2_shared_end(:,3) inds2_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    
    % Easier references to the middle region
    inds_begin = [inds1_begin(:,5) inds2_begin(:,5)];
    inds_end = [inds1_end(:,5) inds2_end(:,5)];
    
    % Calculate the underfull and overfull middle-pattern indices
    inds_end_underfull = inds_begin-1 + bsxfun(@times, N_SI_XY, N_test);
    inds_end_overfull = inds_begin-1 + bsxfun(@times, N_SI_XY+1, N_test);
    
    % Determine how the image should be expanded so that the middle-pattern
    % can be filled-in continuously
    expansion_thresholds = inds_end;
    expansion_offsets = bsxfun(@minus, inds_end_overfull-expansion_thresholds, N_overlap);
    B_neg = expansion_offsets < 0; % Don't allow negative expansions by shifting them back to positive
    dim = repmat([1 2], [size(expansion_offsets, 1) 1]);
    N_test_B_neg_1 = N_test(B_neg(:,1));
    N_test_B_neg_2 = N_test(B_neg(:,2));
    if any(N_test_B_neg_1), expansion_offsets(B_neg & dim == 1) = expansion_offsets(B_neg & dim == 1) + N_test_B_neg_1; end % Backward compatible with R2011a
    if any(N_test_B_neg_2), expansion_offsets(B_neg & dim == 2) = expansion_offsets(B_neg & dim == 2) + N_test_B_neg_2; end % Backward compatible with R2011a
    
    % Calculate 2nd region indices (near the bottom and the right edges).
    inds_2nd_begin = inds_end_overfull;
    inds_2nd_end = bsxfun(@minus, [W H], N_overlap);
    
    % Determine a common test region (ignoring 2nd region) for the local
    % variance minimization.
    inds_begin_max = max(inds_begin, [], 1);
    inds_end_min = min(inds_end, [], 1);
    ind1_test = inds_begin_max(1):inds_end_min(1);
    ind2_test = inds_begin_max(2):inds_end_min(2);
    
    B_test = false(size(I));
    B_test(ind1_test, ind2_test, :) = true;
    
    % Preallocations
%     local_var_kernel = ones(LocalWindowSize);
    local_var_test = zeros(size(N_test));
    
    % Store only the best
    local_var_best = inf;
    N_best = [];
    P_best = [];
    P_offset_best = [];
    ii_best = [];
    B_best = [];
    
    %% Preconditioning
    
    if Debug,
        figure; imshow(permute(I, [2 1 3])); daspect([1 1 1]); title('Before');
    end
    
    % Smoothen the image before analysis if requested
    if GlobalRollingWindowAnalysis,
        oldclass = class(I);
        if ~UseMedian, [~, I] = WITio.fun.image.rolling_window_analysis(I, [1 1 0]);
        else, [~, ~, ~, ~, I] = WITio.fun.image.rolling_window_analysis(I, [1 1 0]); end
        I = cast(I, oldclass); % Restore the original image type
        if Debug,
            figure; imshow(permute(uint8(I), [2 1 3])); daspect([1 1 1]); title('Smoothened');
        end
    end
    
    %% Testing the middle-pattern removal with various side test lengths
    
    fprintf('Testing all side lengths between %d and %d.\n', N_lower, N_upper);
    
    B_Outliers_OR_too_bright = bsxfun(@or, B_Outliers, B_too_bright); % Backward compatible with R2011a
    B_invalid = test_pattern(1, I, B_Outliers_OR_too_bright); % Store invalid to reduce cpu demand of clever_outliers_and_statistics-calls
    if numel(N_test) > 1,
        B_invalid_last = test_pattern(numel(N_test), I, B_Outliers_OR_too_bright); % Store invalid to reduce cpu demand of clever_outliers_and_statistics-calls
        B_invalid = B_invalid & B_invalid_last; % AND-operation to reduce cpu demand of clever_outliers_and_statistics-calls
        for ii = 2:numel(N_test)-1,
            test_pattern(ii, I, B_invalid);
        end
    end
    
    fprintf('Best: %d -> Smallest local variance of %g.\n', N_best, local_var_best);
    
    %% Preparation to the edge pattern calculations
    
    % Prepare boolean map for the edge pattern calculations
    B_best(~get_valid(ii_best, 5)) = false; % Keep only the middle-pattern values
    B_best = B_best | B_too_bright;
    
    if Debug,
        figure; imagesc(B_best(:,:,1).'); daspect([1 1 1]); title('Outliers');
    end
    
    % Continue working with the expanded images
    [I, B_best, B_5] = expand_images_best(I, B_best, get_valid(ii_best, 5));

    % Remove the middle pattern from the original image
    I_best = remove_pattern(I, P_best, B_5, inds_begin(ii_best,:)); % Restore too bright regions if requested
    I_pattern = remove_pattern(ones(size(I), class(I)).*128, P_best, B_5, inds_begin(ii_best,:));
    
    % Continue by calculating the edge patterns (if not to be cropped)
    if ~CropEdgePatterns,
        % Attempt to find edges as post-processing step
        [P_left_edge, P_right_edge, P_top_edge, P_bottom_edge] = find_edge_patterns();
        
        [B_2, B_4, B_6, B_8] = expand_images_best(get_valid_best(2), get_valid_best(4), get_valid_best(6), get_valid_best(8));
        
        inds1_begin = expand_indices_best(1, inds1_begin);
        inds2_begin = expand_indices_best(2, inds2_begin);
        
        % Remove other edge patterns from the original image
        I_best = remove_pattern(I_best, P_left_edge, B_4, [inds1_begin(ii_best,4) inds2_begin(ii_best,4)]);
        I_best = remove_pattern(I_best, P_top_edge, B_2, [inds1_begin(ii_best,2) inds2_begin(ii_best,2)]);
        if NoReferences,
            I_best = remove_pattern(I_best, P_right_edge, B_6, [inds1_begin(ii_best,6) inds2_begin(ii_best,6)]);
            I_best = remove_pattern(I_best, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)]);
        else, % Substract by the expansion offset if using references
            I_best = remove_pattern(I_best, P_right_edge, B_6, [inds1_begin(ii_best,6)-expansion_offsets(ii_best,1) inds2_begin(ii_best,6)]);
            I_best = remove_pattern(I_best, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)-expansion_offsets(ii_best,2)]);
        end
        
        I_pattern = remove_pattern(I_pattern, P_left_edge, B_4, [inds1_begin(ii_best,4) inds2_begin(ii_best,4)]);
        I_pattern = remove_pattern(I_pattern, P_top_edge, B_2, [inds1_begin(ii_best,2) inds2_begin(ii_best,2)]);
        
        if NoReferences,
            I_pattern = remove_pattern(I_pattern, P_right_edge, B_6, [inds1_begin(ii_best,6) inds2_begin(ii_best,6)]);
            I_pattern = remove_pattern(I_pattern, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)]);
        else, % Substract by the expansion offset if using references
            I_pattern = remove_pattern(I_pattern, P_right_edge, B_6, [inds1_begin(ii_best,6)-expansion_offsets(ii_best,1) inds2_begin(ii_best,6)]);
            I_pattern = remove_pattern(I_pattern, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)-expansion_offsets(ii_best,2)]);
        end
    end
    
    %% Generate the final result
    
    % Contract the images
    [I_best, I_pattern] = contract_images_best(I_best, I_pattern);
    
    % On request, undo changes to too bright regions
    if RestoreTooBright, I_best(B_too_bright) = I_too_bright; end
    
    if Debug,
        figure; imshow(permute(I_best, [2 1 3])); daspect([1 1 1]); title('After');
        figure; imshow(permute(I_pattern, [2 1 3])); daspect([1 1 1]); title('Pattern');
    end
    
    % Crop the final result
    cropIndices = [];
    if CropEdgePatterns,
        ind1_middle = inds1_begin(ii_best,5):inds1_end(ii_best,5);
        ind2_middle = inds2_begin(ii_best,5):inds2_end(ii_best,5);
        cropIndices = [ind1_middle([1 end]) ind2_middle([1 end])];
        
        % Crop the results
        I_best = I_best(ind1_middle,ind2_middle,:);
        I_pattern = I_pattern(ind1_middle,ind2_middle,:);
        
        if Debug,
            figure; imshow(permute(I_best, [2 1 3])); daspect([1 1 1]); title('After (Cropped)');
            figure; imshow(permute(I_pattern, [2 1 3])); daspect([1 1 1]); title('Pattern (Cropped)');
        end
    end
    
    % UNUSED EXPERIMENTAL FEATURE BEING DEVELOPED
%     N_over = N_stitch(ii_best);
%     N_under = N_nostitch(ii_best);
%     N_edge = N_overlap(ii_best);
%     P_true = nan(N_over, N_over, S(3));
%     P_true(N_edge-1+(1:N_under),N_edge-1+(1:N_under),:) = P_best(1:N_under,1:N_under,:);
%     P_true(1:N_edge,N_edge-1+(1:N_under),:) = P_best(1:N_edge,1:N_under,:);
%     P_true(end-N_edge:end,N_edge-1+(1:N_under),:) = P_best(end-N_edge:end,1:N_under,:);
% %     P_true(1:N_edge,N_edge-1+(1:N_under),:) = P_left_edge(1:N_edge,1:N_under,:);
% %     P_true(end-N_edge:end,N_edge-1+(1:N_under),:) = P_right_edge(end-N_edge:end,1:N_under,:);
%     P_true(N_edge-1+(1:N_under),1:N_edge,:) = P_top_edge(1:N_under,1:N_edge,:);
%     P_true(N_edge-1+(1:N_under),end-N_edge:end,:) = P_bottom_edge(1:N_under,end-N_edge:end,:);
%     
%     [x, y] = ndgrid(1:N_over, 1:N_over);
%     for ii = 1:S(3),
%         P_true_ii = P_true(:,:,ii);
%         B_nan = isnan(P_true_ii);
%         try, % Requires R2013a or newer!
%             fun = scatteredInterpolant(x(~B_nan), y(~B_nan), P_true_ii(~B_nan), 'linear', 'linear');
%             P_true_ii(B_nan) = fun(x(B_nan), y(B_nan));
%         catch, % For backward compatibility
%             P_true_ii(B_nan) = griddata(x(~B_nan), y(~B_nan), P_true_ii(~B_nan), x(B_nan), y(B_nan), 'linear');
%             P_true_ii(isnan(P_true_ii)) = NaN; % Set extrapolated regions (= NaNs) to zero
%         end
%         P_true(:,:,ii) = P_true_ii;
%     end
%     figure; imagesc(P_true(:,:,1).'); daspect([1 1 1]);
%     figure; imagesc(P_bottom_edge(:,:,1).'); daspect([1 1 1]);
%     
%     B_valid = stitch_patterns(P_true, [1 1], [1 88]);

    %% Helper functions
    
    function B_valid = get_valid(ii, region),
        % Be aware if inds1_begin, inds1_end, inds2_begin and inds2_end
        % have been INTENTIONALLY expanded or contracted when calling this!
        B_valid = false(W, H, D);
        inds1 = inds1_begin(ii,region):inds1_end(ii,region);
        inds2 = inds2_begin(ii,region):inds2_end(ii,region);
        B_valid(inds1,inds2,:) = true;
        % Include the secondary region
        inds1_2nd = inds_2nd_begin(ii,1):inds_2nd_end(ii,1);
        inds2_2nd = inds_2nd_begin(ii,2):inds_2nd_end(ii,2);
        isMiddle = region == 5;
        isMiddleHorizontal = region == 4 || isMiddle || region == 6; 
        isMiddleVertical = region == 2 || isMiddle || region == 8;
        B_valid(inds1,inds2_2nd,:) = isMiddleHorizontal;
        B_valid(inds1_2nd,inds2,:) = isMiddleVertical;
        B_valid(inds1_2nd,inds2_2nd,:) = isMiddle;
    end
    
    function B_valid = get_valid_best(region),
        B_valid = get_valid(ii_best, region);
    end
    
    function B_ref = get_ref(ii, region),
        % Be aware if inds1_begin, inds1_end, inds2_begin and inds2_end
        % have been INTENTIONALLY expanded or contracted when calling this!
        B_ref = false(W, H, D);
        ind1_begin = inds1_begin(ii,5);
        ind2_begin = inds2_begin(ii,5);
        ind1_end = inds1_end(ii,5);
        ind2_end = inds2_end(ii,5);
        switch region,
            case 2, % Top
                inds1 = ind1_begin:ind1_end;
                inds2 = ind2_begin:ind2_begin+N_test(ii)-1;
                B_ref(inds1,inds2,:) = true;
            case 4, % Left
                inds1 = ind1_begin:ind1_begin+N_test(ii)-1;
                inds2 = ind2_begin:ind2_end;
                B_ref(inds1,inds2,:) = true;
            case 6, % Right
                inds1 = ind1_end-N_test(ii):ind1_end;
                inds2 = ind2_begin:ind2_end;
                B_ref(inds1,inds2,:) = true;
            case 8, % Bottom
                inds1 = ind1_begin:ind1_end;
                inds2 = ind2_end-N_test(ii):ind2_end;
                B_ref(inds1,inds2,:) = true;
        end
    end
    
    function B_ref = get_ref_best(region),
        B_ref = get_ref(ii_best, region);
    end
    
    function varargout = expand_indices(ii, dim, varargin),
        % Loop through indices
        for jj = nargin-2:-1:1,
            ind_jj = varargin{jj};
            
            % Expand indices
            B_expanded_jj = ind_jj > expansion_thresholds(ii,dim);
            ind_jj(B_expanded_jj) = ind_jj(B_expanded_jj) + expansion_offsets(ii,dim);
            
            varargout{jj} = ind_jj;
        end
    end
    
    function varargout = expand_indices_best(dim, varargin),
        [varargout{1:nargout}] = expand_indices(ii_best, dim, varargin{:});
    end
    
    function varargout = contract_indices(ii, dim, varargin),
        % Loop through indices
        for jj = nargin-2:-1:1,
            ind_jj = varargin{jj};
            
            % Contract expanded indices
            B_expanded_jj = ind_jj > expansion_thresholds(ii,dim) + expansion_offsets(ii,dim);
            ind_jj(B_expanded_jj) = ind_jj(B_expanded_jj) - expansion_offsets(ii,dim);
            
            % Destroy forbidden indices
            B_forbidden_jj = ind_jj > expansion_thresholds(ii,dim) & ~B_expanded_jj;
            ind_jj(B_forbidden_jj) = []; % Destroy forbidden indices
            
            varargout{jj} = ind_jj;
        end
    end
    
    function varargout = contract_indices_best(dim, varargin),
        [varargout{1:nargout}] = contract_indices(ii_best, dim, varargin{:});
    end
    
    function varargout = expand_images(ii, varargin), % A minor bottleneck. Reduce calls to this if possible. (8.8.2019)
        % Evaluate expanded size
        S_expanded = [W + expansion_offsets(ii,1) H + expansion_offsets(ii,2) D];
        
        % Generate expanded subindices
        inds1 = expand_indices(ii, 1, 1:W);
        inds2 = expand_indices(ii, 2, 1:H);
        inds3 = 1:D;
        
        % Generate expanded indices in memory conservative way (avoiding ndgrid and sub2ind and cast)
        ind_expanded = WITio.fun.generic_sub2ind(S_expanded, inds1, inds2, inds3, 'uint32');
        
%         % Perform linear indexing only once (but apparently slower)
%         B_expanded = false(S_expanded);
%         B_expanded(ind_expanded) = true;
        
        % Loop through images
        for jj = nargin-1:-1:1,
            if islogical(varargin{jj}), varargout{jj} = false(S_expanded); % Makes next line backward compatible with R2011a
            else, varargout{jj} = zeros(S_expanded, class(varargin{jj})); end
            varargout{jj}(ind_expanded) = varargin{jj}; % Linear indexing
%             varargout{jj}(B_expanded) = varargin{jj}; % Logical indexing (but apparently slower)
        end
    end
    
    function varargout = expand_images_best(dim, varargin),
        [varargout{1:nargout}] = expand_images(ii_best, dim, varargin{:});
    end
    
    function varargout = contract_images(ii, varargin),
        B_expanded = expand_images(ii, true(W, H, D)); % Perform linear indexing once
        
        % Loop through images
        for jj = nargin-1:-1:1,
            varargout{jj} = reshape(varargin{jj}(B_expanded), W, H, D); % Then logical indexing
        end
    end
    
    function varargout = contract_images_best(dim, varargin),
        [varargout{1:nargout}] = contract_images(ii_best, dim, varargin{:});
    end
    
    function B_invalid = test_pattern(ii, I, B_invalid),
        if nargin < 3, B_invalid = false(size(I)); end % No known outliers by default
        
        fprintf('%d/%d: %d', ii, numel(N_test), N_test(ii));
        
        % Get valid region for the middle-pattern calculation
        B_valid = get_valid(ii, 5);
        B_invalid = B_invalid | ~B_valid; % Append (negated) to the known outliers
        
        % Temporarily expand
        [inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1)] = expand_indices(ii, 1, inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1));
        [inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2)] = expand_indices(ii, 2, inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2));
        [I, B_invalid] = expand_images(ii, I, B_invalid);
        
        % Calculate the pattern
        [P_ii, B_invalid, P_ii_offset] = find_pattern(I, [N_test(ii) N_test(ii)], inds_begin(ii,:), inds_2nd_end(ii,:), B_invalid);
        
        % Restore by contracting
        [inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1)] = contract_indices(ii, 1, inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1));
        [inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2)] = contract_indices(ii, 2, inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2));
        [I, B_invalid] = contract_images(ii, I, B_invalid);
        
        % Remove pattern from the test area (same for all cases)
        I_test = remove_pattern(I, P_ii, B_test, inds_begin(ii,:));
        I_test = I_test(ind1_test,ind2_test,:); % Keep the test area
        
        % Evaluate local variance in the test area
        local_var_test(ii) = WITio.fun.indep.mynansum(reshape(WITio.fun.indep.mynanstdfilt2(I_test, LocalWindowSize).^2, [], 1)); % Minimize this
%         local_var_test(ii) = WITio.fun.indep.mynansum(reshape(stdfilt(I_test, local_var_kernel).^2, [], 1)); % Minimize this
        
        fprintf(' -> Local variance of %g', local_var_test(ii));
        
        % Update the best if a new minimum
        str_best = '';
        if local_var_best > local_var_test(ii),
            local_var_best = local_var_test(ii);
            N_best = N_test(ii);
            P_best = P_ii;
            P_offset_best = P_ii_offset;
            ii_best = ii;
            B_best = B_invalid;
            
            str_best = ' -> Current best';
        end
        
        fprintf('%s.\n', str_best);
    end

    function [P, B_invalid, P_offset] = find_pattern(I, S_P, Start, End, B_invalid),
        if nargin < 5, B_invalid = false(size(I)); end % No known outliers by default
        
        % Create temporarily hidden figures (if not specified or closed)
        persistent h1 h2;
        if isempty(h1) || isempty(h2) || ~ishandle(h1) || ~ishandle(h2),
            h1 = WITio.fun.visual.invisible_figure;
            h2 = WITio.fun.visual.invisible_figure;
        end
        
        % Indices to the patterned region
        ind1 = Start(1):End(1);
        ind2 = Start(2):End(2);
        
        % The padded size (until the integer number of patterns fit in)
        S_pad = ceil((End(1:2)-Start(1:2)+1)./S_P(1:2)).*S_P(1:2);
        
        % Preallocate
        P = zeros(S_P(1), S_P(2), D);
        I_pad = nan(S_pad); % Preallocate to pad with NaNs once and avoid padarray
        
        P_offset = zeros(1, 1, D);
        
        % Loop through the color channels
        for cc = 1:D,
            if IgnoreChannels(cc), continue; end
            if all(all(B_invalid(:,:,cc), 1), 2), continue; end % Skip if no data to use
            
            I_channel = double(I(:,:,cc)); % Force to double
            if nargin == 5, I_channel(B_invalid(:,:,cc)) = NaN; end % Exclude the known outliers!
            
            % Pad with NaNs.
            I_pad(ind1-Start(1)+1,ind2-Start(2)+1) = I_channel(ind1,ind2);
            
            % Transform to log-space if requested
            if ~AdditiveMode, I_pad = log(I_pad); end
            
            % Reshape to reveal the pattern squares
            I_reshaped = permute(reshape(I_pad, [S_P(1) S_pad(1)/S_P(1) S_P(2) S_pad(2)/S_P(2)]), [1 3 2 4]);
            
            % Make rolling window analysis if requested
            if ~RollingWindowAnalysis, extra_dim = [];,
            else,
                [I_reshaped, ind_RWA] = WITio.fun.image.rolling_window_analysis_transformation(I_reshaped, [1 1 0 0], true);
                extra_dim = ndims(I_reshaped);
            end
            
            % Clever mean of the squares (discarding possible outliers that are outside certain distance in sigmas)
            if UseMedian,
                if ~IsFlat,
                    % Extract blockwise average illumination levels
                    [~, ~, ~, ~, P_cc_offset] = WITio.fun.clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*MinSigmasThreshold);
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, ~, ~, ~, P_cc] = WITio.fun.clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], MinSigmasThreshold);
            else,
                if ~IsFlat,
                    % Extract blockwise average illumination levels
                    [~, P_cc_offset, ~, ~, ~] = WITio.fun.clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*MinSigmasThreshold);
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, P_cc, ~, ~, ~] = WITio.fun.clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], MinSigmasThreshold);
            end
            
            % Remove mean value to minimize changes to the original image
            P_offset(cc) = WITio.fun.indep.mynanmean(P_cc(:));
            P_cc = P_cc - P_offset(cc);
            
            % Take into account the blockwise averaging
            if ~IsFlat,
                P_cc_offset = repmat(P_cc_offset, [S_P(1) S_P(2)]);
                P_cc_offset(B_cc) = NaN;
                P_offset(cc) = WITio.fun.indep.mynanmean(P_cc_offset(:)) + P_offset(cc);
            end
            
            % Replace NaNs with linearly interpolated values
            [X, Y] = ndgrid(1:size(P_cc, 1), 1:size(P_cc, 2));
            B_isnan = isnan(P_cc);
            
            try, % Requires R2013a or newer!
                F = scatteredInterpolant(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), 'linear', 'linear');
                P_cc(B_isnan) = F(X(B_isnan), Y(B_isnan));
            catch, % For backward compatibility
                P_cc(B_isnan) = griddata(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), X(B_isnan), Y(B_isnan), 'linear');
                P_cc(isnan(P_cc)) = 0; % Set extrapolated regions (= NaNs) to zero
            end

            % Construct boolean map for outliers if requested
            if RollingWindowAnalysis && (nargout > 1 || Debug),
                S_B_cc = size(B_cc);
                B_cc = reshape(accumarray(ind_RWA(ind_RWA>0),~B_cc(ind_RWA>0)) == 0, S_B_cc(1:end-1));
            end
            
            % Store the found outlier for output
            if nargout > 1,
                B_cc = reshape(permute(B_cc, [1 3 2 4]), S_pad);
                B_invalid(Start(1):Start(1)-1+S_pad(1),Start(2):Start(2)-1+S_pad(2),cc) = B_cc;
            end
            
            if Debug,
                figure(h1);
                WITio.fun.visual.nanimagesc(P_cc.');
                daspect([1 1 1]);
                title(sprintf('Found pattern, color channel = %d', cc));
                set(h1, 'Visible', 'on'); 
                
                % Show the used image dataset without the outliers
                I_reshaped = reshape(permute(I_reshaped, [1 3 2 4]), S_pad);
                if nargout <= 1, B_cc = reshape(permute(B_cc, [1 3 2 4]), S_pad); end
                I_reshaped(B_cc) = NaN;
                
                figure(h2);
                WITio.fun.visual.nanimagesc(I_reshaped.');
                daspect([1 1 1]);
                title(sprintf('Used image without outliers, color channel = %d', cc));
                set(h2, 'Visible', 'on'); 
            end
            
            P(:,:,cc) = P_cc;
        end
    end

    function varargout = find_edge_patterns(),
        % Uses I_best and B_best, which are expanded images!
        
        % [Left Right Top Bottom]
        regions = [4 6 2 8];
        
        % Test if to use references (which are more cpu intensive)
        if NoReferences, N_ref = 0;
        else, N_ref = N_best; end
        
        % Indices to Video Stitching image
        ind1_begin = [inds1_begin(ii_best,4) inds1_begin(ii_best,6)-N_ref inds1_begin(ii_best,2) inds1_begin(ii_best,8)];
        ind1_end = [inds1_end(ii_best,4)+N_ref inds1_end(ii_best,6) inds_2nd_end(ii_best,1) inds_2nd_end(ii_best,1)];
        ind2_begin = [inds2_begin(ii_best,4) inds2_begin(ii_best,6) inds2_begin(ii_best,2) inds2_begin(ii_best,8)-N_ref];
        ind2_end = [inds_2nd_end(ii_best,2) inds_2nd_end(ii_best,2) inds2_end(ii_best,2)+N_ref inds2_end(ii_best,8)];
        
        % Expand indices
        [ind1_begin, ind1_end] = expand_indices_best(1, ind1_begin, ind1_end);
        [ind2_begin, ind2_end] = expand_indices_best(2, ind2_begin, ind2_end);
        
        % Edge pattern side lengths
        N1 = [ind1_end(1)-ind1_begin(1)+1 ind1_end(2)-ind1_begin(2)+1 N_best N_best];
        N2 = [N_best N_best ind2_end(3)-ind2_begin(3)+1 ind2_end(4)-ind2_begin(4)+1];
        
        % Indices to the needed reference region in the pattern
        ind1_ref = {N1(1)-N_ref+1:N1(1); 1:N_ref; 1:N1(3); 1:N1(4)};
        ind2_ref = {1:N2(1); 1:N2(2); N2(3)-N_ref+1:N2(3); 1:N_ref};
        
        % Indices to the pattern without the reference region
        ind1_wo_ref = {1:N1(1)-N_ref; N_ref+1:N1(2); 1:N1(3); 1:N1(4)};
        ind2_wo_ref = {1:N2(1); 1:N2(2); 1:N2(3)-N_ref; N_ref+1:N2(4)};
        
        % Loop through the edge regions
        for ss = 4:-1:1,
            % Get valid region for the pattern calculation (including the
            % reference region)
            if NoReferences, B_valid = expand_images_best(get_valid_best(regions(ss)));
            else, B_valid = expand_images_best(get_valid_best(regions(ss)) | get_ref_best(regions(ss))); end
            B_invalid = B_best | ~B_valid; % Append (negated) to the known outliers
            
            % Find the pattern
            S_P = [N1(ss) N2(ss)];
            Start = [ind1_begin(ss) ind2_begin(ss)];
            End = [ind1_end(ss) ind2_end(ss)];
            [P_ss, ~, P_ss_offset] = find_pattern(I_best, S_P, Start, End, B_invalid);
            
            % Remove best mean value to minimize changes to the original image
            P_ss = bsxfun(@plus, P_ss, P_ss_offset - P_offset_best); % Backward compatible with R2011a
            
            % Preserve pattern-to-pattern continuity using the reference
            if ~NoReferences,
                edge = P_ss(ind1_ref{ss},ind2_ref{ss},:);
                [~, cshift] = WITio.fun.clever_statistics_and_outliers(-edge, -3, 1); % Here -3 reads as NOT 3rd dimension
                P_ss = bsxfun(@plus, P_ss, cshift); % Zero the reference region
            end
            
            % Discard the reference pixels
            varargout{ss} = P_ss(ind1_wo_ref{ss},ind2_wo_ref{ss},:);
        end
    end
    
    % Please note that this is unable to produce correct pattern for the
    % first and last full rows and columns, because their pattern differ
    % from the middle region. Nor it can correctly produce edge pattern for
    % the aborted Video Stitching images.
    function I_wo_P = remove_pattern(I, P, B_valid, P_TopLeft), % Low memory usage via loops
        I_wo_P = I; % Retain the original image data type!
        
        if nargin < 3 || isempty(B_valid), B_valid = true(size(I)); end
        if nargin < 4 || isempty(P_TopLeft), P_TopLeft = ones(1,2); end
        
        % Determine valid bounding box to speed-up the process
        B_valid_any_3 = any(B_valid, 3); % Once
        ind1 = find(any(B_valid_any_3, 2));
        if isempty(ind1), return; end
        ind1 = min(ind1):max(ind1);
        ind2 = find(any(B_valid_any_3, 1));
        if isempty(ind2), return; end
        ind2 = min(ind2):max(ind2);
        
        % Truncate to the bounding box
        I = I(ind1, ind2, :);
        B_valid = B_valid(ind1, ind2, :);
        
        % Shift P_TopLeft to the bounding box
        offset = [ind1(1) ind2(1)]-1;
        P_TopLeft = P_TopLeft(:).' - offset;
        
        % Negate the P
        P = -P;
        
        % If multiplicative mode, then transform back to linear-space
        if ~AdditiveMode, P = exp(P); end
        
        % Get sizes
        S_I = size(I); % Size of an image
        S_P = size(P); % Size of a pattern (inverted)
        S_G = ceil(S_I(1:2)./S_P(1:2)); % Size of pattern grid
        z = 1:S_I(3); % Preallocated constant vector
        
        % Repmat either P or I once
        if S_P(3) == 1 && S_I(3) ~= 1,
            P = repmat(P, [1 1 S_I(3)]);
            S_P(3) = S_I(3);
        end
        if S_I(3) == 1 && S_P(3) ~= 1,
            I = repmat(I, [1 1 S_P(3)]);
            S_I(3) = S_P(3);
        end
        
        % Repmat TrueBlackColor once (only if used)
        isBlack = all(TrueBlackColor) == 0;
        if ~isBlack,
            Black = bsxfun(@times, double(TrueBlackColor), ones(size(S_P)));
        end
        
        % Calculate once
        [x_P0, y_P0, z] = ndgrid(1:S_P(1), 1:S_P(2), z);
        ind_P0 = WITio.fun.generic_sub2ind(S_P, x_P0, y_P0, z, '-nobsxfun'); % Call once
        
        % Shift P once
        x_P = mod((1:S_P(1))-P_TopLeft(1), S_P(1))+1; % Shift indices
        y_P = mod((1:S_P(2))-P_TopLeft(2), S_P(2))+1; % Shift indices
        P = P(x_P, y_P, :);
        
%         % Remove pattern via a simple loop
%         for x_G = 1:S_G(1),
%             % Generate indices in x-direction
%             x_I = x_P0 + (x_G-1).*S_P(1);
%             
%             % Truncate (if partial) to valid indices in x-direction
%             B_x = x_I <= S_I(1);
%             if any(any(any(B_x, 1), 2), 3) == false, continue; end % Skip to next if no valid
%             
%             for y_G = 1:S_G(2),
%                 % Generate indices in y-direction
%                 y_I = y_P0 + (y_G-1).*S_P(2);
%                 
%                 % Truncate (if partial) to valid indices in y-direction
%                 B_y = y_I <= S_I(2);
%                 if any(any(any(B_y, 1), 2), 3) == false, continue; end % Skip to next if no valid
%                 
%                 B_xy = B_x & B_y;
%                 ind_I_valid = sub2ind(S_I, x_I(B_xy), y_I(B_xy), z(B_xy)); % generic_sub2ind with '-nobsxfun' is twice as slow
%                 ind_P_valid = ind_P0(B_xy);
%                 
%                 B_valid_here = B_valid(ind_I_valid);
%                 ind_I_valid = ind_I_valid(B_valid_here);
%                 ind_P_valid = ind_P_valid(B_valid_here);
%                 
%                 % Remove pattern piece-by-piece
%                 I_here = double(I(ind_I_valid));
%                 P_here = P(ind_P_valid);
%                 if AdditiveMode,
%                     I(ind_I_valid) = I_here + P_here;
%                 else, % Multiplicative mode
%                     if isBlack, I(ind_I_valid) = I_here .* P_here;
%                     else,
%                         Black_here = Black(ind_P_valid);
%                         I(ind_I_valid) = (I_here - Black_here) .* P_here + Black_here;
%                     end
%                 end
%             end
%         end
        
        % Remove pattern via repmat (apparently ~1.5x faster than the loop)
        % The padded size (until the integer number of patterns fit in)
        S_pad = ceil(S_I(1:2)./S_P(1:2)).*S_P(1:2);
        
        % Preallocate and avoid padarray
        I_cc_pad = zeros(S_pad, class(I));
        B_valid_pad = false(S_pad);
        
        % Do linear indexing only once
        B_pad = false(S_pad);
        B_pad(1:S_I(1),1:S_I(2)) = true;
        
        for cc = 1:S_I(3),
            if IgnoreChannels(cc), continue; end
            I_cc = I(:,:,cc);
            I_here = double(I_cc(B_valid(:,:,cc)));
            I_cc_pad(B_pad) = I(:,:,cc);
            B_valid_pad(B_pad) = B_valid(:,:,cc);
            
            % Use repmat because it was successfully used earlier
            P_repmat = reshape(permute(repmat(P(:,:,cc), [1 1 S_G(1) S_G(2)]), [1 3 2 4]), S_pad);
            P_here = P_repmat(B_valid_pad);
            clear P_repmat;
            
            if AdditiveMode,
                I_cc_pad(B_valid_pad) = I_here + P_here;
            else, % Multiplicative mode
                if isBlack, I_cc_pad(B_valid_pad) = I_here .* P_here;
                else,
                    Black_repmat = reshape(permute(repmat(double(Black(:,:,cc)), [1 1 S_G(1) S_G(2)]), [1 3 2 4]), S_pad);
                    Black_here = Black_repmat(B_valid_pad);
                    clear Black_repmat;
                    I_cc_pad(B_valid_pad) = (I_here - Black_here) .* P_here + Black_here;
                end
            end
            
            I(:,:,cc) = reshape(I_cc_pad(B_pad), S_I(1:2));
        end
        
        % Restore the original shape
        I_wo_P(ind1, ind2, :) = I;
    end
    
    % UNUSED EXPERIMENTAL FEATURE BEING DEVELOPED
%     function P_mix = stitch_patterns(P, P1_TopLeft, P2_TopLeft),
%         S_P = size(P);
%         S_mix = [max(P1_TopLeft, P2_TopLeft)+S_P(1:2)-1 S_P(3)];
%         P_mix = nan(S_mix);
%         
%         % If multiplicative mode, then transform back to linear-space
%         if ~AdditiveMode, P = exp(P); end
%         
%         x_P = 1:S_P(1);
%         y_P = 1:S_P(2);
%         z_P = 1:S_P(3);
%         
%         x_P1 = x_P + P1_TopLeft(1)-1;
%         y_P1 = y_P + P1_TopLeft(2)-1;
%         x_P2 = x_P + P2_TopLeft(1)-1;
%         y_P2 = y_P + P2_TopLeft(2)-1;
%         
%         Bx1 = any(bsxfun(@eq, x_P1, x_P2(:)), 1);
%         Bx2 = any(bsxfun(@eq, x_P1(:), x_P2), 1);
%         
%         By1 = any(bsxfun(@eq, y_P1, y_P2(:)), 1);
%         By2 = any(bsxfun(@eq, y_P1(:), y_P2), 1);
%         
%         B1 = repmat(bsxfun(@and, Bx1(:), By1), [1 1 S_P(3)]);
%         B2 = repmat(bsxfun(@and, Bx2(:), By2), [1 1 S_P(3)]);
%         
%         y_overlap = y_P1(By1);
%         wy_P1 = interp1([min(y_overlap)-1 max(y_overlap)+1], [1 0], y_P1, 'linear');
%         wy_P2 = interp1([min(y_overlap)-1 max(y_overlap)+1], [0 1], y_P2, 'linear');
%         
%         ind_P = WITio.fun.generic_sub2ind(S_P, x_P, y_P, z_P);
%         ind_P1 = WITio.fun.generic_sub2ind(S_mix, x_P1, y_P1, z_P);
%         ind_P2 = WITio.fun.generic_sub2ind(S_mix, x_P2, y_P2, z_P);
%         
%         P1 = P;
%         P1(:,y_P(By1),:) = bsxfun(@times, P1(:,y_P(By1),:), wy_P1(By1));
%         
%         P2 = P;
%         P2(:,y_P(By2),:) = bsxfun(@times, P2(:,y_P(By2),:), wy_P2(By2));
%         
%         P_mix(ind_P1(~B1)) = P(ind_P(~B1));
%         P_mix(ind_P2(~B2)) = P(ind_P(~B2));
%         P_mix(ind_P1(B1)) = P1(ind_P(B1)) + P2(ind_P(B2));
%         
%         % If multiplicative mode, then transform back to log-space
%         if ~AdditiveMode, P_mix = log(P_mix); end
%         
%         figure; imagesc(P_mix(:,:,1).'); daspect([1 1 1]);
%     end
end
