% BSD 3-Clause License (LICENSE.txt)
% Copyright (c) 2019, Joonas T. Holmi (jtholmi@gmail.com)
% All rights reserved.

function [I_best, N_best, cropIndices] = unpattern_video_stitching_helper(I, S_P_grid, varargin),
    % Repeating patterns in Video Stitching images often result from the
    % Video Image quality issues. The Video Image response is extracted by
    % minimizing the local variance.
    
    % ASSUMPTIONS: This algorithm assumes that the given input I (1) is not
    % truncated in any way and (2) is the original Video Stitching image
    % generated by WITec software. It also assumes a 5% overlap.
    
    % REQUIREMENTS: The given input S_P_grid must be larger than 3-by-3.
    
    % Correction is done in the logarithmic space, because the pattern is a
    % multiplicative error, not an additive error. This is reasonable by
    % realizing that camera CCD response variation and all the losses along
    % the optical path from the light source to the camera are
    % multiplicative in nature. After all, camera CCD counts are assumed to
    % be nearly linearly dependent on the incoming light power.
    
    % This algorithm utilizes the behaviour of the WITec software's Video
    % Stitching feature that apparently stitches same-sized squares (in px)
    % together with ~5% overlaps and truncates the excess from the right
    % and bottom edges. Huge stitchings are automatically DOWN-SCALED even
    % if saved in High Resolution mode.
    
    % Please note that this algorithm is best suited for Video Stitching
    % images with '(High Resolution)'-tag, which have not been down-scaled
    % twice (unless the original image was bigger than 64 million pixels)
    % and consist of integer sized squares. Video Stitching images without
    % '(High Resolution)'-tag are always down-scaled to 1024^2 = 1048576
    % pixels (nearest).
    
    % Give warning if code detects 64 million pixels or 1048576 pixels.
    
    % Main findings regarding the Video Stitching feature:
    % (0) The motorized stage performs some additional steps before, during
    % and after the stitching procedure.
    % (1) During the procedure, the motorized stage makes constant steps
    % (in px but not in µm due to the stage's step size of i.e. 100 nm).
    % (2) Each captured Video Image is truncated to a constant square (in
    % px), discarding the less-reliable edge regions. The down-scaling (if
    % requested by the WITec software) is then apparently done here.
    % (3) Each resulting square is then linearly weighted from 0 to 1 at 
    % the overlap regions and summed together to obtain the final stiching
    % result. It would seem that no interpolation is used to account for
    % the subpixel displacement.
    % (4) Additional down-scaling is done for pictures which are not saved
    % in High Resolution mode.
    
%     % '-DisableEdgePatterns' with optional extra input for customization: [left, right, top, bottom]
    % '-SigmasThreshold'
    % '-RestoreTooBright'
    % '-TrueBlackColor'
    % '-Flat'
    % '-OverlapRatio'
    % '-LocalWindowSize'
    % '-AdditiveMode'
    % '-UseMedian'
    % '-NoSmoothing'
    % '-debug'
    % '-LowResMaxPixels'
    % '-HighResMaxPixels'
    % '-DisableAutoIgnoreChannels'
    % '-IgnoreChannels'
    % '-NoCrop'
    
    % Requirements: Image Processing Toolbox (due to usage of stdfilt)
    
    S = size(I);
    W = S(1); % Image width
    H = S(2); % Image height
    D = S(3); % Image depth or number of channels
    
    % START OF VARARGIN PARSING
    
    % Parse varargin before any dashed str
    out = varargin_dashed_str_removed('', varargin);
    N_sides = [];
    if numel(out) > 0, N_sides = out{1}; end
    
    % Parse varargin input
    RestoreTooBright = varargin_dashed_str_exists('RestoreTooBright', varargin); % By default, do not restore too bright
    IsFlat = varargin_dashed_str_exists('Flat', varargin); % By default, do not assume flatness
    AdditiveMode = varargin_dashed_str_exists('AdditiveMode', varargin); % By default, fix in a multiplicative mode
    UseMedian = varargin_dashed_str_exists('UseMedian', varargin); % By default, use mean values
    RollingWindowAnalysis = varargin_dashed_str_exists('RollingWindowAnalysis', varargin); % By default, smoothen the image
    CropEdgePatterns = ~varargin_dashed_str_exists('NoCrop', varargin); % By default, crop the image
    AutoIgnoreChannels = ~varargin_dashed_str_exists('DisableAutoIgnoreChannels', varargin); % By default, automatically ignore channels that have 50% too dark or too bright in the image
    debug = varargin_dashed_str_exists('debug', varargin); % By default, do not show debug visuals
    EdgePatterns = ~varargin_dashed_str_exists('DisableEdgePatterns', varargin); % By default, enable edge patterns
    
    % Check if SigmasThreshold was specified
    out = varargin_dashed_str_datas('SigmasThreshold', varargin, -1);
    SigmasThreshold = 2; % 2.25 % Too low (<~2) begins to label true data as outliers but too high (>~4) is contaminated by outliers
    if numel(out) > 0, SigmasThreshold = out{1}; end
    
    % Check if TrueBlackColor was specified
    out = varargin_dashed_str_datas('TrueBlackColor', varargin, -1);
    TrueBlackColor = 0;
    if numel(out) > 0, TrueBlackColor = out{1}; end
    TrueBlackColor = reshape(TrueBlackColor, 1, 1, []); % Enforce correct shape
    
    % Check if LocalWindowSize was specified
    out = varargin_dashed_str_datas('LocalWindowSize', varargin, -1);
    LocalWindowSize = 17;
    if numel(out) > 0, LocalWindowSize = out{1}; end
    
    % Check if OverlapRatio was specified
    out = varargin_dashed_str_datas('OverlapRatio', varargin, -1);
    OverlapRatio = 0.05; % Interpreted from experimental data
    if numel(out) > 0, OverlapRatio = out{1}; end
    
    % Check if LowResMaxPixels was specified
    out = varargin_dashed_str_datas('LowResMaxPixels', varargin, -1);
    LowResMaxPixels = 1024.^2; % Interpreted from experimental data
    if numel(out) > 0, LowResMaxPixels = out{1}; end
    
    % Check if HighResMaxPixels was specified
    out = varargin_dashed_str_datas('HighResMaxPixels', varargin, -1);
    HighResMaxPixels = 64e6; % Interpreted from experimental data
    if numel(out) > 0, HighResMaxPixels = out{1}; end
    
    % Check if IgnoreChannels was specified
    out = varargin_dashed_str_datas('IgnoreChannels', varargin, -1);
    IgnoreChannels = [];
    if numel(out) > 0, IgnoreChannels = out{1}; end
    if numel(IgnoreChannels) == 1, IgnoreChannels = repmat(IgnoreChannels, [1 D]);
    elseif ~isempty(IgnoreChannels), IgnoreChannels = reshape(IgnoreChannels, [1 D]); end
    
    % END OF VARARGIN PARSING
    
    % Treat too bright or dark regions as outliers
    try, I_max = intmax(class(I)); % Only for an integer type image
    catch, I_max = 1.0; end % For single and double type image
    B_too_bright = I >= I_max;
    
    % Automatically ignore all channels that have less than 50% useful data
    if AutoIgnoreChannels && isempty(IgnoreChannels),
        B_too_dark = I <= 0;
        IgnoreChannels(sum(sum(B_too_dark | B_too_bright, 1), 2) > W.*H./2) = true;
    end
    
    % Detect possible Low and High Resolution down-scalings and warn about them
    N_LR_max = LowResMaxPixels; % Low Resolution maximum amount of pixels
    if ((W-1)*H < N_LR_max || W*(H-1) < N_LR_max) && ((W+1)*H > N_LR_max || W*(H+1) > N_LR_max),
        warning('Video Stitching image may be down-scaled due to Low Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_LR_max);
    end
    N_HR_max = HighResMaxPixels; % High Resolution maximum amount of pixels
    if (W+1)*H > N_HR_max || W*(H+1) > N_HR_max,
        warning('Video Stitching image may be down-scaled due to High Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_HR_max);
    end
    
    S_P_grid_CF = OverlapRatio/(1-OverlapRatio); % A correction factor derived below
    if ~EdgePatterns, S_P_grid_CF = 0; end % Disable edge patterns
    if isempty(N_sides),
        % Find bounds that produce same amount of S_squares
        
        % Systematic derivation (only in x-direction but equivalent in y-direction):
        % Number of patterns, NW (KNOWN CONSTANT!)
        % Pattern overlap (ratio from 0 to 1), O (UNCERTAIN CONSTANT!)
        % Pattern width, W (TO BE SOLVED!)
        % Pattern width (without overlap), w = (1-O)*W (TO BE SOLVED!)
        % Pattern overlap dW = W-w = w/(1-O) - w = w * O/(1-O)
        % Image width, IW = NW*W-(NW-2)*dW = NW*w + 2*dW (lower bound) % DOUBLE-CHECKED!
        % Image width, IW = (NW-1)*W-(NW-2)*dW = (NW-1)*w + dW (upper bound) % DOUBLE-CHECKED!
        % Inner square width, w = (IW-2*dW)/NW = (IW-2*w*O/(1-O))/NW => IW/(NW+2*O/(1-O)) = IW/(NW+2*CF) (lower bound)
        % Inner square width, w = (IW-dW)/(NW-1) = (IW-w*O/(1-O))/(NW-1) => IW/(NW-1+O/(1-O)) = IW/(NW-1+CF) (upper bound)
        % Correction factor, CF = O/(1-O)
        
        N_side_lower = max(ceil(S(1:2)./(S_P_grid + 2.*S_P_grid_CF)));
        N_side_upper = min(floor(S(1:2)./(S_P_grid-1 + S_P_grid_CF)));
        
        N_sides = N_side_lower:N_side_upper;
    else,
        N_side_lower = min(N_sides);
        N_side_upper = max(N_sides);
    end
    N_overlaps = round(N_sides.*S_P_grid_CF); % Rounded to nearest integer
    N_full_sides = N_sides + N_overlaps;
    
    % Construct widths of the edge patterns
    W_edges = [N_overlaps(:) N_full_sides(:) N_overlaps(:) N_full_sides(:)]; % Left Right Top Bottom
    if ~EdgePatterns, W_edges(:,:) = 0; end % Disable edge patterns
    
    % Construct shared indices
    inds1_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,1)+1 W-W_edges(:,2)+1]; % Left Middle Right
    inds1_shared_end = [W_edges(:,1) W-W_edges(:,2) repmat(W, [size(W_edges, 1) 1])]; % Left Middle Right
    inds2_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,3)+1 H-W_edges(:,4)+1]; % Top Middle Bottom
    inds2_shared_end = [W_edges(:,3) H-W_edges(:,4) repmat(H, [size(W_edges, 1) 1])]; % Top Middle Bottom
    
    % Construct indices for all possible patterns
    inds1_begin = [ ...
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds1_end = [ ...
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_begin = [ ...
        inds2_shared_begin(:,1) inds2_shared_begin(:,1) inds2_shared_begin(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_begin(:,2) inds2_shared_begin(:,2) inds2_shared_begin(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_begin(:,3) inds2_shared_begin(:,3) inds2_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_end = [ ...
        inds2_shared_end(:,1) inds2_shared_end(:,1) inds2_shared_end(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_end(:,2) inds2_shared_end(:,2) inds2_shared_end(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_end(:,3) inds2_shared_end(:,3) inds2_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    
    % Precalculate the truncated indices. Shift first row by N_overlaps.
    % Truncate away minimum of N_full_sides from the last rows. Treat
    % discarded regions differently due to their different patterns.
    inds_begin = [inds1_begin(:,5) inds2_begin(:,5)];
    inds_end = [inds1_end(:,5) inds2_end(:,5)];
    S_P_grids = floor(bsxfun(@rdivide, inds_end-inds_begin+1, N_sides(:)));
    inds_end_full = inds_begin-1 + bsxfun(@times, S_P_grids, N_sides(:));
    if min(S_P_grids(:)) <= 1, error('ERROR: Grid must be larger than 3-by-3!'); end
    
    % Use precalculated indices to select a common test region
    inds_begin_max = max(inds_begin,[],1);
    inds_end_min = min(inds_end,[],1);
    ind1_test = inds_begin_max(1):inds_end_min(1);
    ind2_test = inds_begin_max(2):inds_end_min(2);
    
    % Store all the local variances
    N_local = LocalWindowSize;
    kernel_local = ones(N_local);
    vars_to_min = zeros(size(N_sides));
    
    % Store only the best
    var_to_min_best = inf;
    N_best = [];
    P_best = [];
    ii_best = [];
    B_best = [];
    
    % Debug
    if debug,
        figure; imshow(permute(I, [2 1 3])); daspect([1 1 1]); title('Before');
    end
    
    % Smoothen the image before analysis if requested
    I_before = I;
%     if Smoothen,
%         if ~UseMedian, [~, I] = rolling_window_analysis(I_before, [1 1 0]);
%         else, [~, ~, ~, ~, I] = rolling_window_analysis(I_before, [1 1 0]); end
%         if debug,
%             figure; imshow(permute(uint8(I), [2 1 3])); daspect([1 1 1]); title('Smoothening');
%         end
%     end
    
    fprintf('Testing all possible side lengths between %d and %d.\n', N_side_lower, N_side_upper);
    B_invalid = test_pattern(1, B_too_bright); % To reduce cpu demand of clever_outliers_and_statistics-calls
    if numel(N_sides) > 1,
        B_invalid_last = test_pattern(numel(N_sides), B_too_bright);
        B_invalid = B_invalid & B_invalid_last; % AND-operation to reduce cpu demand of clever_outliers_and_statistics-calls
        for ii = 2:numel(N_sides)-1,
            test_pattern(ii, B_invalid);
        end
    end
    B_best(inds_end(ii_best,1)+1:end,:,:) = false;
    B_best(:,inds_end(ii_best,2)+2:end,:) = false;
    B_best = B_best(1:S(1),1:S(2),:);
    B_best = B_best | B_too_bright;
    fprintf('Best: %d -> PRIMARY variance of %g (smaller the better).\n', N_best, var_to_min_best);
    
    if debug,
        figure; imagesc(B_best(:,:,1).'); daspect([1 1 1]);
    end
    
    S_pad = [N_best+ceil((S(1:2)-N_overlaps(ii_best))./N_best).*N_best S(3)];
    B_pad = false(S_pad); % Preallocate to pad with falses once and avoid padarray
    I_pad = nan(S_pad); % Preallocate to pad with NaNs once and avoid padarray
    ind1 = (N_best-N_overlaps(ii_best))+(1:S(1));
    ind2 = (N_best-N_overlaps(ii_best))+(1:S(2));
    B_pad(ind1,ind2,:) = B_best;
    I_pad(ind1,ind2,:) = I;
    I_pad(B_pad) = NaN;
    % Reshape to reveal the squares
    I_pad = permute(reshape(I_pad, [N_best S_pad(1)/N_best N_best S_pad(2)/N_best S_pad(3)]), [1 3 2 4 5]);
    
    if ~IsFlat,
        [~, ~, ~, ~, offset] = clever_statistics_and_outliers(I_pad, [1 2], 3); % Extract blockwise average illumination levels
        I_pad = bsxfun(@minus, I_pad, offset);
    end
    B_pad = clever_statistics_and_outliers(I_pad, [3 4], 3);
    B_pad = reshape(permute(B_pad, [1 3 2 4 5]), S_pad);
    B_pad = B_pad(ind1,ind2,:);
    B_best = B_pad;
    
    % TODOOO
    
    if debug,
        figure; imagesc(B_best(:,:,1).'); daspect([1 1 1]);
    end
    
%     I = remove_pattern(I, P_best, [], [], [-N_overlaps(ii_best) -N_overlaps(ii_best)]);
%     I_best = I;
    
    % Remove middle edge pattern from the original image
    I = I_before;
    I_best = remove_pattern(I, P_best, inds_begin(ii_best,:), inds_end(ii_best,:));% Restore too bright regions if requested
    I_bg = remove_pattern(ones(size(I), 'like', I).*128, P_best, [], [], [-N_overlaps(ii_best) -N_overlaps(ii_best)]);
%     I_bg = remove_pattern(ones(size(I), 'like', I).*128, P_best, inds_begin(ii_best,:), inds_end(ii_best,:));
    
    cropIndices = [];
    if CropEdgePatterns,
        cropIndices = [inds1_begin(ii_best,5) inds1_end(ii_best,5) inds2_begin(ii_best,5) inds2_end(ii_best,5)];
        ind1_mid = inds1_begin(ii_best,5):inds1_end(ii_best,5);
        ind2_mid = inds2_begin(ii_best,5):inds2_end(ii_best,5);
        I = I(ind1_mid,ind2_mid,:);
        I_best = I_best(ind1_mid,ind2_mid,:);
        I_bg = I_bg(ind1_mid,ind2_mid,:);
        B_too_bright = B_too_bright(ind1_mid,ind2_mid,:);
    else,
        % Attempt to find edges as post-processing step
        [P_left_edge, P_right_edge, P_top_edge, P_bottom_edge] = find_edge_patterns(ii_best, B_best);
        
        % Remove other edge patterns from the original image
        I_best = remove_pattern(I_best, P_left_edge, [], [inds1_end(ii_best,4) H], [0 -N_overlaps(ii_best)]);
        I_best = remove_pattern(I_best, P_right_edge, [inds1_begin(ii_best,6) 1], [], [0 -N_overlaps(ii_best)]);
        I_best = remove_pattern(I_best, P_top_edge, [], [W inds2_end(ii_best,2)], [-N_overlaps(ii_best) 0]);
        I_best = remove_pattern(I_best, P_bottom_edge, [1 inds2_begin(ii_best,8)], [], [-N_overlaps(ii_best) 0]);
        
        I_bg = remove_pattern(I_bg, P_left_edge, [], [inds1_end(ii_best,4) H], [0 -N_overlaps(ii_best)]);
        I_bg = remove_pattern(I_bg, P_right_edge, [inds1_begin(ii_best,6) 1], [], [0 -N_overlaps(ii_best)]);
        I_bg = remove_pattern(I_bg, P_top_edge, [], [W inds2_end(ii_best,2)], [-N_overlaps(ii_best) 0]);
        I_bg = remove_pattern(I_bg, P_bottom_edge, [1 inds2_begin(ii_best,8)], [], [-N_overlaps(ii_best) 0]);
    end
    
    if RestoreTooBright,
        I_best(B_too_bright) = I(B_too_bright);
    end
    
    % Debug
    if debug,
        figure; imshow(permute(uint8(I_best), [2 1 3])); daspect([1 1 1]); title('After');
        figure; imshow(permute(uint8(I_bg), [2 1 3])); daspect([1 1 1]); title('Pattern');
    end
    
    function B_invalid = test_pattern(ii, B_invalid),
        if nargin < 2, B_invalid = false(size(I)); end
        
        N_side_ii = N_sides(ii);
        fprintf('%d/%d: %d', ii, numel(N_sides), N_side_ii);
        
        [P_ii, B_invalid] = find_pattern([N_side_ii N_side_ii], inds_begin(ii,:), inds_end(ii,:), B_invalid);
        
        % Remove pattern from test region
        I_test = remove_pattern(I, P_ii, inds_begin_max, inds_end_min, inds_begin_max-inds_begin(ii,2));
        I_test = I_test(ind1_test,ind2_test,:);

        % Evaluate local variance in the test area (same for all cases)
        vars_to_min(ii) = mynansum(reshape(stdfilt(I_test, kernel_local).^2, [], 1)); % Minimize this

        fprintf(' -> PRIMARY variance of %g (smaller the better).\n', vars_to_min(ii));
        
        % Update the best if a new minimum
        if var_to_min_best > vars_to_min(ii),
            var_to_min_best = vars_to_min(ii);
            N_best = N_side_ii;
            P_best = P_ii;
            ii_best = ii;
            B_best = B_invalid;
        end
    end

    function varargout = find_edge_patterns(ii, B_invalid),
        % [Left Right Top Bottom]
        % Indices to Video Stitching image
        ind1_begin = [inds1_begin(ii,4) inds1_begin(ii,6)-N_sides(ii) inds1_begin(ii,2) inds1_begin(ii,8)];
        ind1_end = [inds1_end(ii,4)+N_sides(ii) inds1_end(ii,6) inds1_end(ii,2) inds1_end(ii,8)];
        ind2_begin = [inds2_begin(ii,4) inds2_begin(ii,6) inds2_begin(ii,2) inds2_begin(ii,8)-N_sides(ii)];
        ind2_end = [inds2_end(ii,4) inds2_end(ii,6) inds2_end(ii,2)+N_sides(ii) inds2_end(ii,8)];
        % Pattern side lengths
        N1 = [W_edges(ii,1)+N_sides(ii) W_edges(ii,2)+N_sides(ii) N_sides(ii) N_sides(ii)];
        N2 = [N_sides(ii) N_sides(ii) W_edges(ii,3)+N_sides(ii) W_edges(ii,4)+N_sides(ii)];
        % Indices to the reference region in the pattern
        ind1_ref = {N1(1)-N_sides(ii)+1:N1(1); 1:N_sides(ii); 1:N1(3); 1:N1(4)};
        ind2_ref = {1:N2(1); 1:N2(2); N2(3)-N_sides(ii)+1:N2(3); 1:N_sides(ii)};
        % Indices to the pattern without the reference region
        ind1_wo_ref = {1:N1(1)-N_sides(ii); N_sides(ii)+1:N1(2); 1:N1(3); 1:N1(4)};
        ind2_wo_ref = {1:N2(1); 1:N2(2); 1:N2(3)-N_sides(ii); N_sides(ii)+1:N2(4)};
        % Offsets that shift indices to the reference
        offset1 = [0 inds_end_full(ii,1)-inds_end(ii,1)+N_overlaps(ii) 0 0];
        offset2 = [0 0 0 inds_end_full(ii,2)-inds_end(ii,2)+N_overlaps(ii)];
        % Loop through the edges
        for ss = 4:-1:1,
            S_P = [N1(ss) N2(ss)];
            Start = [ind1_begin(ss) ind2_begin(ss)];
            End = [ind1_end(ss) ind2_end(ss)];
            P_ss = find_pattern(S_P, Start, End, B_invalid);
            % Preserve pattern-to-pattern continuity using the reference
            edge = P_ss(ind1_ref{ss},ind2_ref{ss},:);
            edge_ref = P_best(mod((1:end)-offset1(ss)-1, end)+1,mod((1:end)-offset2(ss)-1, end)+1,:);
%             [~, cshift] = clever_statistics_and_outliers(- edge + 0, -3, 1); % Here -3 reads as NOT 3rd dimension
            [~, cshift] = clever_statistics_and_outliers(- edge + edge_ref, -3, 1); % Here -3 reads as NOT 3rd dimension
            P_ss = bsxfun(@plus, P_ss, cshift);
            % Discard reference pixels added for continuity preservation
            varargout{ss} = P_ss(ind1_wo_ref{ss},ind2_wo_ref{ss},:);
        end
    end

    function [P, B_invalid] = find_pattern(S_P, Start, End, B_invalid),
        if nargin < 4, B_invalid = false(size(I)); end
        N_side_1 = S_P(1);
        N_side_2 = S_P(2);
        P = zeros(N_side_1, N_side_2, D);
        ind1 = Start(1):End(1);
        ind2 = Start(2):End(2);
        S_truncated = ceil((End(1:2)-Start(1:2)+1)./S_P(1:2)).*S_P(1:2);
        I_truncated = nan(S_truncated); % Preallocate to pad with NaNs once and avoid padarray
        
        sigmas_threshold = SigmasThreshold;
        for cc = 1:D,
            if IgnoreChannels(cc), continue; end
            
            I_channel = double(I(:,:,cc));
            if nargin == 4, I_channel(B_invalid(:,:,cc)) = NaN; end % Exclude common outliers!
            
            % Truncate and pad with NaNs
            I_truncated(ind1-Start(1)+1,ind2-Start(2)+1) = I_channel(ind1,ind2);
            
            % Transform to log-space if requested
            if ~AdditiveMode, I_truncated = log(I_truncated); end
            
            % Reshape to reveal the squares
            I_reshaped = permute(reshape(I_truncated, [N_side_1 S_truncated(1)/N_side_1 N_side_2 S_truncated(2)/N_side_2]), [1 3 2 4]);
            
            % Make rolling window analysis if requested
            if ~RollingWindowAnalysis, extra_dim = [];,
            else,
                [I_reshaped, ind_RWA] = rolling_window_analysis_transformation(I_reshaped, [1 1 0 0], true);
                extra_dim = ndims(I_reshaped);
            end
            
            % Clever mean of the squares (discarding possible outliers that are outside certain distance in sigmas)
            if UseMedian,
                if ~IsFlat,
                    [~, ~, ~, ~, P_cc_offset] = clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*sigmas_threshold); % Extract blockwise average illumination levels
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, ~, ~, ~, P_cc] = clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], sigmas_threshold);
            else,
                if ~IsFlat,
                    [~, P_cc_offset, ~, ~, ~] = clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*sigmas_threshold); % Extract blockwise average illumination levels
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, P_cc, ~, ~, ~] = clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], sigmas_threshold);
            end
            
            P_cc = P_cc - mynanmean(P_cc(:)); % Remove mean value to minimize changes to the original image
            
            % Replace NaNs with linearly interpolated values
            [X, Y] = ndgrid(1:size(P_cc, 1), 1:size(P_cc, 2));
            B_isnan = isnan(P_cc);
            
            try, % Requires R2013a or newer!
                F = scatteredInterpolant(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), 'linear', 'linear');
                P_cc(B_isnan) = F(X(B_isnan), Y(B_isnan));
            catch, % For backward compatibility
                P_cc(B_isnan) = griddata(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), X(B_isnan), Y(B_isnan), 'linear');
                P_cc(isnan(P_cc)) = 0; % Set extrapolated regions (= NaNs) to zero
            end

            % Construct boolean map for outliers if requested
            if RollingWindowAnalysis,
                S_B_cc = size(B_cc);
                B_cc = reshape(accumarray(ind_RWA(ind_RWA>0),~B_cc(ind_RWA>0)) == 0, S_B_cc(1:end-1));
            end
            B_cc = reshape(permute(B_cc, [1 3 2 4]), S_truncated);
            if nargout > 1,
                B_invalid(Start(1):Start(1)-1+S_truncated(1),Start(2):Start(2)-1+S_truncated(2),cc) = B_cc;
            end
            
%             if debug,
%                 figure; nanimagesc(P_cc.'); daspect([1 1 1]);
%                 I_reshaped = reshape(permute(I_reshaped, [1 3 2 4]), S_truncated);
%                 I_reshaped(B_cc) = NaN;
%                 figure; nanimagesc(I_reshaped.'); daspect([1 1 1]);
%             end
            P(:,:,cc) = P_cc;
        end
    end
    
    % Please note that this is unable to produce correct pattern for the
    % first and last full rows and columns, because their pattern differ
    % from the middle region. Nor it can correctly produce edge pattern for
    % the aborted Video Stitching images.
    function I_wo_P = remove_pattern(I, P, Start, End, ShiftFromStart), % Low memory usage via loops
        I_wo_P = I; % Retain the original image data type!
        
        % Negate the P
        P = -P;
        
        % If multiplicative mode, then transform back to linear-space
        if ~AdditiveMode, P = exp(P-eps); end
        
        % Get sizes
        S_I = size(I); % Size of an image
        S_P = size(P); % Size of a pattern (inverted)
        
        % Set pattern range
        if nargin < 3 || isempty(Start), Start = ones(1,2); end
        if nargin < 4 || isempty(End), End = S_I(1:2); end
        if nargin < 5 || isempty(ShiftFromStart), ShiftFromStart = zeros(1,2); end
        End = min(End, S_I(1:2)); % Keep End within the image bounds
        
        % Get other sizes
        S_G = ceil((End-Start+1)./S_P(1:2)); % Size of pattern grid
        
        % Remove pattern without memory-intensive repmat
        for x_G = 1:S_G(1),
            % Generate indices in x-direction
            x_C = 1:S_P(1);
            x_I = (x_G-1).*S_P(1)+x_C+Start(1)-1;
            x_C = mod(x_C-1+ShiftFromStart(1), S_P(1))+1; % Shift indices
            
            % Truncate (if partial) to valid indices in x-direction
            bw_x = x_I >= 1 & x_I <= End(1);
            if any(bw_x) == false, continue; end % Skip to next if no valid
            x_C = x_C(bw_x);
            x_I = x_I(bw_x);
            
            for y_G = 1:S_G(2),
                % Generate indices in y-direction
                y_C = 1:S_P(2);
                y_I = (y_G-1).*S_P(2)+y_C+Start(2)-1;
                y_C = mod(y_C-1+ShiftFromStart(2), S_P(2))+1; % Shift indices
                
                % Truncate (if partial) to valid indices in y-direction
                bw_y = y_I >= 1 & y_I <= End(2);
                if any(bw_y) == false, continue; end % Skip to next if no valid
                y_C = y_C(bw_y);
                y_I = y_I(bw_y);
                
                % Remove pattern piece-by-piece
                if AdditiveMode,
                    I_wo_P(x_I,y_I,:) = bsxfun(@plus, double(I(x_I,y_I,:)), P(x_C,y_C,:));
                else, % Multiplicative mode
                    if all(TrueBlackColor == 0), I_wo_P(x_I,y_I,:) = bsxfun(@times, double(I(x_I,y_I,:)), P(x_C,y_C,:));
                    else, I_wo_P(x_I,y_I,:) = bsxfun(@plus, bsxfun(@times, bsxfun(@minus, double(I(x_I,y_I,:)), TrueBlackColor), P(x_C,y_C,:)), TrueBlackColor); end
                end
            end
        end
    end
end
