% BSD 3-Clause License (LICENSE.txt)
% Copyright (c) 2019, Joonas T. Holmi (jtholmi@gmail.com)
% All rights reserved.

function [I_best, N_best, cropIndices] = unpattern_video_stitching_helper(I, S_P_grid, varargin),
    % Repeating patterns in Video Stitching images often result from the
    % Video Image quality issues. The Video Image response is extracted by
    % minimizing the local variance.
    
    % ASSUMPTIONS: This algorithm assumes that the given input I (1) is not
    % truncated in any way and (2) is the original Video Stitching image
    % generated by WITec software. It also assumes a 5% overlap by default.
    
    % REQUIREMENTS: The given input S_P_grid must be larger than 3-by-3.
    
    % Correction is done in the logarithmic space, because the pattern is a
    % multiplicative error, not an additive error. This is reasonable by
    % realizing that camera CCD response variation and all the losses along
    % the optical path from the light source to the camera are
    % multiplicative in nature. After all, camera CCD counts are assumed to
    % be nearly linearly dependent on the incoming light power.
    
    % This algorithm utilizes the behaviour of the WITec software's Video
    % Stitching feature that apparently stitches same-sized squares (in px)
    % together with ~5% overlaps and truncates the excess from the right
    % and bottom edges. Huge stitchings are automatically DOWN-SCALED even
    % if saved in High Resolution mode.
    
    % Please note that this algorithm is best suited for Video Stitching
    % images with '(High Resolution)'-tag, which have not been down-scaled
    % twice (unless the original image was bigger than 64 million pixels)
    % and consist of integer sized squares. Video Stitching images without
    % '(High Resolution)'-tag are always down-scaled to 1024^2 = 1048576
    % pixels (nearest).
    
    % Give warning if code detects 64 million pixels or 1048576 pixels.
    
    % Main findings regarding the Video Stitching feature:
    % (0) The motorized stage performs some additional steps before, during
    % and after the stitching procedure.
    % (1) During the procedure, the motorized stage makes constant steps
    % (in px but not in µm due to the stage's step size of i.e. 100 nm).
    % (2) Each captured Video Image is truncated to a constant square (in
    % px), discarding the less-reliable edge regions. The down-scaling (if
    % requested by the WITec software) is then apparently done here.
    % (3) Each resulting square is then linearly weighted from 0 to 1 at 
    % the overlap regions and summed together to obtain the final stiching
    % result. It would seem that no interpolation is used to account for
    % the subpixel displacement.
    % (4) Additional down-scaling is done for pictures which are not saved
    % in High Resolution mode.
    
%     % '-DisableEdgePatterns' with optional extra input for customization: [left, right, top, bottom]
    % '-SigmasThreshold'
    % '-RestoreTooBright'
    % '-TrueBlackColor'
    % '-Flat'
    % '-OverlapRatio'
    % '-LocalWindowSize'
    % '-AdditiveMode'
    % '-UseMedian'
    % '-NoSmoothing'
    % '-debug'
    % '-LowResMaxPixels'
    % '-HighResMaxPixels'
    % '-DisableAutoIgnoreChannels'
    % '-IgnoreChannels'
    % '-NoCrop'
    
    % Requirements: Image Processing Toolbox (due to usage of stdfilt)
    
    S = size(I);
    W = S(1); % Image width
    H = S(2); % Image height
    D = S(3); % Image depth or number of channels
    
    % START OF VARARGIN PARSING
    
    % Parse varargin before any dashed str
    out = varargin_dashed_str_removed('', varargin);
    N_sides = [];
    if numel(out) > 0, N_sides = out{1}; end
    
    % Parse varargin input
    RestoreTooBright = varargin_dashed_str_exists('RestoreTooBright', varargin); % By default, do not restore too bright
    IsFlat = varargin_dashed_str_exists('Flat', varargin); % By default, do not assume flatness
    AdditiveMode = varargin_dashed_str_exists('AdditiveMode', varargin); % By default, fix in a multiplicative mode
    UseMedian = varargin_dashed_str_exists('UseMedian', varargin); % By default, use mean values
    RollingWindowAnalysis = varargin_dashed_str_exists('RollingWindowAnalysis', varargin); % By default, smoothen the image
    CropEdgePatterns = ~varargin_dashed_str_exists('NoCrop', varargin); % By default, crop the image
    AutoIgnoreChannels = ~varargin_dashed_str_exists('DisableAutoIgnoreChannels', varargin); % By default, automatically ignore channels that have 50% too dark or too bright in the image
    debug = varargin_dashed_str_exists('debug', varargin); % By default, do not show debug visuals
    EdgePatterns = ~varargin_dashed_str_exists('DisableEdgePatterns', varargin); % By default, enable edge patterns
    
    % Check if SigmasThreshold was specified
    datas = varargin_dashed_str_datas('SigmasThreshold', varargin, -1);
    SigmasThreshold = 2; % 2.25 % Too low (<~2) begins to label true data as outliers but too high (>~4) is contaminated by outliers
    if numel(datas) > 0, SigmasThreshold = datas{1}; end
    
    % Check if TrueBlackColor was specified
    datas = varargin_dashed_str_datas('TrueBlackColor', varargin, -1);
    TrueBlackColor = 0;
    if numel(datas) > 0, TrueBlackColor = datas{1}; end
    TrueBlackColor = reshape(TrueBlackColor, 1, 1, []); % Enforce correct shape
    
    % Check if LocalWindowSize was specified
    datas = varargin_dashed_str_datas('LocalWindowSize', varargin, -1);
    LocalWindowSize = 17;
    if numel(datas) > 0, LocalWindowSize = datas{1}; end
    
    % Check if OverlapRatio was specified
    datas = varargin_dashed_str_datas('OverlapRatio', varargin, -1);
    OverlapRatio = 0.05; % Interpreted from experimental data
    if numel(datas) > 0, OverlapRatio = datas{1}; end
    
    % Check if LowResMaxPixels was specified
    datas = varargin_dashed_str_datas('LowResMaxPixels', varargin, -1);
    LowResMaxPixels = 1024.^2; % Interpreted from experimental data
    if numel(datas) > 0, LowResMaxPixels = datas{1}; end
    
    % Check if HighResMaxPixels was specified
    datas = varargin_dashed_str_datas('HighResMaxPixels', varargin, -1);
    HighResMaxPixels = 64e6; % Interpreted from experimental data
    if numel(datas) > 0, HighResMaxPixels = datas{1}; end
    
    % Check if IgnoreChannels was specified
    datas = varargin_dashed_str_datas('IgnoreChannels', varargin, -1);
    IgnoreChannels = [];
    if numel(datas) > 0, IgnoreChannels = datas{1}; end
    if numel(IgnoreChannels) == 1, IgnoreChannels = repmat(IgnoreChannels, [1 D]);
    elseif ~isempty(IgnoreChannels), IgnoreChannels = reshape(IgnoreChannels, [1 D]); end
    
    % END OF VARARGIN PARSING
    
    % Treat too bright or dark regions as outliers
    try, I_max = intmax(class(I)); % Only for an integer type image
    catch, I_max = 1.0; end % For single and double type image
    B_too_bright = I >= I_max;
    
    % Automatically ignore all channels that have less than 50% useful data
    if AutoIgnoreChannels && isempty(IgnoreChannels),
        B_too_dark = I <= 0;
        IgnoreChannels(sum(sum(B_too_dark | B_too_bright, 1), 2) > W.*H./2) = true;
    end
    
    % Detect possible Low and High Resolution down-scalings and warn about them
    N_LR_max = LowResMaxPixels; % Low Resolution maximum amount of pixels
    if ((W-1)*H < N_LR_max || W*(H-1) < N_LR_max) && ((W+1)*H > N_LR_max || W*(H+1) > N_LR_max),
        warning('Video Stitching image may be down-scaled due to Low Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_LR_max);
    end
    N_HR_max = HighResMaxPixels; % High Resolution maximum amount of pixels
    if (W+1)*H > N_HR_max || W*(H+1) > N_HR_max,
        warning('Video Stitching image may be down-scaled due to High Resolution maximum of %d pixels, most likely leading to non-integer sized squares! This may prevent the algorithm from finding a working solution!', N_HR_max);
    end
    
    S_P_grid_CF = OverlapRatio/(1-OverlapRatio); % A correction factor derived below
    if ~EdgePatterns, S_P_grid_CF = 0; end % Disable edge patterns
    if isempty(N_sides),
        % Find bounds that produce same amount of S_squares
        
        % Systematic derivation (only in x-direction but equivalent in y-direction):
        % Number of patterns, NW (KNOWN CONSTANT!)
        % Pattern overlap (ratio from 0 to 1), O (UNCERTAIN CONSTANT!)
        % Pattern width, W (TO BE SOLVED!)
        % Pattern width (without overlap), w = (1-O)*W (TO BE SOLVED!)
        % Pattern overlap dW = W-w = w/(1-O) - w = w * O/(1-O)
        % Image width, IW = NW*W-(NW-2)*dW = NW*w + 2*dW (lower bound) % DOUBLE-CHECKED!
        % Image width, IW = (NW-1)*W-(NW-2)*dW = (NW-1)*w + dW (upper bound) % DOUBLE-CHECKED!
        % Inner square width, w = (IW-2*dW)/NW = (IW-2*w*O/(1-O))/NW => IW/(NW+2*O/(1-O)) = IW/(NW+2*CF) (lower bound)
        % Inner square width, w = (IW-dW)/(NW-1) = (IW-w*O/(1-O))/(NW-1) => IW/(NW-1+O/(1-O)) = IW/(NW-1+CF) (upper bound)
        % Correction factor, CF = O/(1-O)
        
        N_side_lower = max(ceil(S(1:2)./(S_P_grid + 2.*S_P_grid_CF)));
        N_side_upper = min(floor(S(1:2)./(S_P_grid-1 + S_P_grid_CF)));
        
        N_sides = N_side_lower:N_side_upper;
    else,
        N_side_lower = min(N_sides);
        N_side_upper = max(N_sides);
    end
    N_stitch_overlaps = round(N_sides.*S_P_grid_CF); % Rounded to nearest integer
    N_stitch_sides = N_sides + N_stitch_overlaps;
    N_no_overlap_sides = N_sides - N_stitch_overlaps;
    
    S_P_grids = floor(bsxfun(@rdivide, bsxfun(@minus, S(1:2), N_stitch_overlaps(:)+N_stitch_sides(:)), N_sides(:)));
    
    % Construct widths of the edge patterns
    W_edges = [N_stitch_overlaps(:) N_stitch_sides(:) N_stitch_overlaps(:) N_stitch_sides(:)]; % Left Right Top Bottom
    if ~EdgePatterns, W_edges(:,:) = 0; end % Disable edge patterns
    
    % Construct shared indices
    inds1_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,1)+1 W-W_edges(:,2)+1]; % Left Middle Right
    inds1_shared_end = [W_edges(:,1) W-W_edges(:,2) repmat(W, [size(W_edges, 1) 1])]; % Left Middle Right
    inds2_shared_begin = [ones(size(W_edges, 1), 1) W_edges(:,3)+1 H-W_edges(:,4)+1]; % Top Middle Bottom
    inds2_shared_end = [W_edges(:,3) H-W_edges(:,4) repmat(H, [size(W_edges, 1) 1])]; % Top Middle Bottom
    
    % Construct indices for all possible patterns
    inds1_begin = [ ...
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_begin(:,1) inds1_shared_begin(:,2) inds1_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds1_end = [ ...
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Top-Left Top-Middle Top-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Middle-Left Middle-Middle Middle-Right
        inds1_shared_end(:,1) inds1_shared_end(:,2) inds1_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_begin = [ ...
        inds2_shared_begin(:,1) inds2_shared_begin(:,1) inds2_shared_begin(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_begin(:,2) inds2_shared_begin(:,2) inds2_shared_begin(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_begin(:,3) inds2_shared_begin(:,3) inds2_shared_begin(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    inds2_end = [ ...
        inds2_shared_end(:,1) inds2_shared_end(:,1) inds2_shared_end(:,1) ... % Top-Left Top-Middle Top-Right
        inds2_shared_end(:,2) inds2_shared_end(:,2) inds2_shared_end(:,2) ... % Middle-Left Middle-Middle Middle-Right
        inds2_shared_end(:,3) inds2_shared_end(:,3) inds2_shared_end(:,3) ... % Bottom-Left Bottom-Middle Bottom-Right
        ];
    
    inds_begin = [inds1_begin(:,5) inds2_begin(:,5)];
    inds_end = [inds1_end(:,5) inds2_end(:,5)];
    
    inds_end_underfull = inds_begin-1 + bsxfun(@times, S_P_grids, N_sides(:));
    inds_end_overfull = inds_begin-1 + bsxfun(@times, S_P_grids+1, N_sides(:));
    
    expansion_thresholds = inds_end;
    expansion_offsets = bsxfun(@minus, inds_end_overfull-expansion_thresholds, N_stitch_overlaps(:));
    
    inds_2nd_begin = inds_end_overfull;
    inds_2nd_end = bsxfun(@minus, [W H], N_stitch_overlaps(:));
    
    if min(S_P_grids(:)) <= 1, error('ERROR: Grid must be larger than 3-by-3!'); end
    
    % Use precalculated indices to select a common test region (ignoring
    % 2nd region)
    inds_begin_max = max(inds_begin,[],1);
    inds_end_min = min(inds_end,[],1);
    ind1_test = inds_begin_max(1):inds_end_min(1);
    ind2_test = inds_begin_max(2):inds_end_min(2);
    
    B_test = false(size(I));
    B_test(ind1_test, ind2_test, :) = true;
    
    % Store all the local variances
    N_local = LocalWindowSize;
    kernel_local = ones(N_local);
    vars_to_min = zeros(size(N_sides));
    
    % Store only the best
    var_to_min_best = inf;
    N_best = [];
    P_best = [];
    ii_best = [];
    B_best = [];
    
    % Debug
    if debug,
        figure; imshow(permute(I, [2 1 3])); daspect([1 1 1]); title('Before');
    end
    
    % Smoothen the image before analysis if requested
    I_before = I;
%     if Smoothen,
%         if ~UseMedian, [~, I] = rolling_window_analysis(I_before, [1 1 0]);
%         else, [~, ~, ~, ~, I] = rolling_window_analysis(I_before, [1 1 0]); end
%         if debug,
%             figure; imshow(permute(uint8(I), [2 1 3])); daspect([1 1 1]); title('Smoothening');
%         end
%     end
    
    fprintf('Testing all possible side lengths between %d and %d.\n', N_side_lower, N_side_upper);
    B_invalid = test_pattern(1, I, B_too_bright); % To reduce cpu demand of clever_outliers_and_statistics-calls
    if numel(N_sides) > 1,
        B_invalid_last = test_pattern(numel(N_sides), I, B_too_bright);
        B_invalid = B_invalid & B_invalid_last; % AND-operation to reduce cpu demand of clever_outliers_and_statistics-calls
        for ii = 2:numel(N_sides)-1,
            test_pattern(ii, I, B_invalid);
        end
    end
    
    B_best(~get_valid(ii_best, 5)) = false;
    B_best = B_best | B_too_bright;
    fprintf('Best: %d -> PRIMARY variance of %g (smaller the better).\n', N_best, var_to_min_best);
    
    if debug,
        figure; imagesc(B_best(:,:,1).'); daspect([1 1 1]);
    end
    
    I = I_before;
    
    [I, B_5] = expand_images(ii_best, I, get_valid(ii_best, 5));

    % Remove middle edge pattern from the original image
    I_best = remove_pattern(I, P_best, B_5, inds_begin(ii_best,:));% Restore too bright regions if requested
    I_bg = remove_pattern(ones(size(I), 'like', I).*128, P_best, B_5, inds_begin(ii_best,:));% Restore too bright regions if requested
    
    I = contract_images(ii_best, I);

    cropIndices = [];
    if CropEdgePatterns,
        ind1_middle = inds1_begin(ii_best,5):inds1_end(ii_best,5);
        ind2_middle = inds2_begin(ii_best,5):inds2_end(ii_best,5);
        cropIndices = [ind1_middle([1 end]) ind2_middle([1 end])];
        I = I(ind1_middle,ind2_middle,:);
        I_best = I_best(ind1_middle,ind2_middle,:);
        I_bg = I_bg(ind1_middle,ind2_middle,:);
        B_too_bright = B_too_bright(ind1_middle,ind2_middle,:);
    else,
        % Attempt to find edges as post-processing step
        [P_left_edge, P_right_edge, P_top_edge, P_bottom_edge] = find_edge_patterns(ii_best, I, B_best);
        
        [B_2, B_4, B_6, B_8] = expand_images(ii_best, get_valid(ii_best, 2), get_valid(ii_best, 4), get_valid(ii_best, 6), get_valid(ii_best, 8));
        
        inds1_begin = expand_indices(ii_best, 1, inds1_begin);
        inds2_begin = expand_indices(ii_best, 2, inds2_begin);
        
        % Remove other edge patterns from the original image
        I_best = remove_pattern(I_best, P_left_edge, B_4, [inds1_begin(ii_best,4) inds2_begin(ii_best,4)]);
        I_best = remove_pattern(I_best, P_right_edge, B_6, [inds1_begin(ii_best,6)-expansion_offsets(ii_best,1) inds2_begin(ii_best,6)]);
        I_best = remove_pattern(I_best, P_top_edge, B_2, [inds1_begin(ii_best,2) inds2_begin(ii_best,2)]);
        I_best = remove_pattern(I_best, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)-expansion_offsets(ii_best,2)]);

        I_bg = remove_pattern(I_bg, P_left_edge, B_4, [inds1_begin(ii_best,4) inds2_begin(ii_best,4)]);
        I_bg = remove_pattern(I_bg, P_right_edge, B_6, [inds1_begin(ii_best,6)-expansion_offsets(ii_best,1) inds2_begin(ii_best,6)]);
        I_bg = remove_pattern(I_bg, P_top_edge, B_2, [inds1_begin(ii_best,2) inds2_begin(ii_best,2)]);
        I_bg = remove_pattern(I_bg, P_bottom_edge, B_8, [inds1_begin(ii_best,8) inds2_begin(ii_best,8)-expansion_offsets(ii_best,2)]);
    end
    
    [I_best, I_bg] = contract_images(ii_best, I_best, I_bg);
    
    if RestoreTooBright,
        I_best(B_too_bright) = I(B_too_bright);
    end
    
    % Debug
    if debug,
        figure; imshow(permute(uint8(I_best), [2 1 3])); daspect([1 1 1]); title('After');
        figure; imshow(permute(uint8(I_bg), [2 1 3])); daspect([1 1 1]); title('Pattern');
    end
    
%     function B_valid = stitch_patterns(P, ind1, ind2),
%         w_ii_on_jj = interp1([minmax_ii(1) minmax_jj(1) minmax_ii(2) minmax_jj(2)], [1 1 0 0], x_ii, 'linear');
%         w_jj_on_ii = interp1([minmax_ii(1) minmax_jj(1) minmax_ii(2) minmax_jj(2)], [0 0 1 1], x_jj, 'linear');
%     end
    
    function B_valid = get_valid(ii, region),
        B_valid = false(W, H, D);
        inds1 = inds1_begin(ii,region):inds1_end(ii,region);
        inds2 = inds2_begin(ii,region):inds2_end(ii,region);
        B_valid(inds1,inds2,:) = true;
        % Include the secondary region
        inds1_2nd = inds_2nd_begin(ii,1):inds_2nd_end(ii,1);
        inds2_2nd = inds_2nd_begin(ii,2):inds_2nd_end(ii,2);
        isMiddle = region == 5;
        isMiddleHorizontal = region == 4 || isMiddle || region == 6; 
        isMiddleVertical = region == 2 || isMiddle || region == 8;
        B_valid(inds1,inds2_2nd,:) = isMiddleHorizontal;
        B_valid(inds1_2nd,inds2,:) = isMiddleVertical;
        B_valid(inds1_2nd,inds2_2nd,:) = isMiddle;
    end
    
    function B_ref = get_ref(ii, region),
        B_ref = false(W, H, D);
        ind1_begin = inds1_begin(ii,5);
        ind2_begin = inds2_begin(ii,5);
        ind1_end = inds1_end(ii,5);
        ind2_end = inds2_end(ii,5);
        switch region,
            case 2, % Top
                inds1 = ind1_begin:ind1_end;
                inds2 = ind2_begin:ind2_begin+N_sides(ii)-1;
                B_ref(inds1,inds2,:) = true;
            case 4, % Left
                inds1 = ind1_begin:ind1_begin+N_sides(ii)-1;
                inds2 = ind2_begin:ind2_end;
                B_ref(inds1,inds2,:) = true;
            case 6, % Right
                inds1 = ind1_end-N_sides(ii):ind1_end;
                inds2 = ind2_begin:ind2_end;
                B_ref(inds1,inds2,:) = true;
            case 8, % Bottom
                inds1 = ind1_begin:ind1_end;
                inds2 = ind2_end-N_sides(ii):ind2_end;
                B_ref(inds1,inds2,:) = true;
        end
    end
    
    function varargout = expand_indices(ii, dim, varargin),
        % Loop through indices
        for jj = nargin-2:-1:1,
            ind_jj = varargin{jj};
            
            % Expand indices
            B_expanded_jj = ind_jj > expansion_thresholds(ii,dim);
            ind_jj(B_expanded_jj) = ind_jj(B_expanded_jj) + expansion_offsets(ii,dim);
            
            varargout{jj} = ind_jj;
        end
    end
    
    function varargout = contract_indices(ii, dim, varargin),
        % Loop through indices
        for jj = nargin-2:-1:1,
            ind_jj = varargin{jj};
            
            % Contract expanded indices
            B_expanded_jj = ind_jj > expansion_thresholds(ii,dim) + expansion_offsets(ii,dim);
            ind_jj(B_expanded_jj) = ind_jj(B_expanded_jj) - expansion_offsets(ii,dim);
            
            % Destroy forbidden indices
            B_forbidden_jj = ind_jj > expansion_thresholds(ii,dim) & ~B_expanded_jj;
            ind_jj(B_forbidden_jj) = []; % Destroy forbidden indices
            
            varargout{jj} = ind_jj;
        end
    end
    
    function varargout = expand_images(ii, varargin),
        % Evaluate expanded size
        S_expanded = [W + expansion_offsets(ii,1) H + expansion_offsets(ii,2) D];
        
        % Generate expanded subindices
        inds1 = expand_indices(ii, 1, 1:W);
        inds2 = expand_indices(ii, 2, 1:H);
        inds3 = 1:D;
        
        % Generate expanded indices in memory conservative way (avoiding ndgrid and sub2ind and cast)
        ind_expanded = generic_sub2ind(S_expanded, inds1, inds2, inds3, 'uint32');
        
        % Loop through images
        for jj = nargin-1:-1:1,
            varargout{jj} = zeros(S_expanded, 'like', varargin{jj});
            varargout{jj}(ind_expanded) = varargin{jj}; % Linear indexing
        end
    end
    
    function varargout = contract_images(ii, varargin),
        B_expanded = expand_images(ii, true(W, H, D)); % Perform linear indexing once
        
        % Loop through images
        for jj = nargin-1:-1:1,
            varargout{jj} = reshape(varargin{jj}(B_expanded), W, H, D); % Then logical indexing
        end
    end
    
    function B_invalid = test_pattern(ii, I, B_invalid),
        if nargin < 2, B_invalid = false(size(I)); end
        
        N_side_ii = N_sides(ii);
        S_P_ii = [N_side_ii N_side_ii];
        fprintf('%d/%d: %d', ii, numel(N_sides), N_side_ii);
        
        B_valid = get_valid(ii, 5);
        [inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1)] = expand_indices(ii, 1, inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1));
        [inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2)] = expand_indices(ii, 2, inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2));
        B_invalid = B_invalid | ~B_valid;
        [I, B_invalid] = expand_images(ii, I, B_invalid);
        
        [P_ii, B_invalid] = find_pattern(I, S_P_ii, inds_begin(ii,:), inds_2nd_end(ii,:), B_invalid);
        
        [inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1)] = contract_indices(ii, 1, inds_begin(ii,1), inds_end(ii,1), inds_2nd_end(ii,1));
        [inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2)] = contract_indices(ii, 2, inds_begin(ii,2), inds_end(ii,2), inds_2nd_end(ii,2));
        [I, B_invalid] = contract_images(ii, I, B_invalid);
        
        % Remove pattern from test region
        I_test = remove_pattern(I, P_ii, B_test, inds_begin(ii,:));
        I_test = I_test(ind1_test,ind2_test,:);
        
        % Evaluate local variance in the test area (same for all cases)
        vars_to_min(ii) = mynansum(reshape(stdfilt(I_test, kernel_local).^2, [], 1)); % Minimize this
        
        fprintf(' -> PRIMARY variance of %g (smaller the better).\n', vars_to_min(ii));
        
        % Update the best if a new minimum
        if var_to_min_best > vars_to_min(ii),
            var_to_min_best = vars_to_min(ii);
            N_best = N_side_ii;
            P_best = P_ii;
            ii_best = ii;
            B_best = B_invalid;
        end
    end

    function varargout = find_edge_patterns(ii, I, B_invalid),
        [I, B_invalid] = expand_images(ii, I, B_invalid);
        
        % [Left Right Top Bottom]
        % Indices to Video Stitching image
        ind1_begin = [inds1_begin(ii,4) inds1_begin(ii,6)-N_sides(ii) inds1_begin(ii,2) inds1_begin(ii,8)];
        ind1_end = [inds1_end(ii,4)+N_sides(ii) inds1_end(ii,6) inds_2nd_end(ii,1) inds_2nd_end(ii,1)];
        ind2_begin = [inds2_begin(ii,4) inds2_begin(ii,6) inds2_begin(ii,2) inds2_begin(ii,8)-N_sides(ii)];
        ind2_end = [inds_2nd_end(ii,2) inds_2nd_end(ii,2) inds2_end(ii,2)+N_sides(ii) inds2_end(ii,8)];
        
        [ind1_begin, ind1_end] = expand_indices(ii, 1, ind1_begin, ind1_end);
        [ind2_begin, ind2_end] = expand_indices(ii, 2, ind2_begin, ind2_end);
        
        N_ref = N_sides(ii);
        
        % Pattern side lengths
        N1 = [ind1_end(1)-ind1_begin(1)+1 ind1_end(2)-ind1_begin(2)+1 N_ref N_ref];
        N2 = [N_ref N_ref ind2_end(3)-ind2_begin(3)+1 ind2_end(4)-ind2_begin(4)+1];
        % Indices to the reference region in the pattern
        ind1_ref = {N1(1)-N_ref+1:N1(1); 1:N_ref; 1:N1(3); 1:N1(4)};
        ind2_ref = {1:N2(1); 1:N2(2); N2(3)-N_ref+1:N2(3); 1:N_ref};
        % Indices to the pattern without the reference region
        ind1_wo_ref = {1:N1(1)-N_ref; N_ref+1:N1(2); 1:N1(3); 1:N1(4)};
        ind2_wo_ref = {1:N2(1); 1:N2(2); 1:N2(3)-N_ref; N_ref+1:N2(4)};
        % Offsets that shift indices to the reference
        offset1 = [0 inds_end_underfull(ii,1)-inds_end(ii,1) 0 0];
        offset2 = [0 0 0 inds_end_underfull(ii,2)-inds_end(ii,2)];
        % Loop through the edges
        regions = [4 6 2 8];
        for ss = [4 2 3 1], % 4:-1:1,
            B_valid = expand_images(ii, get_valid(ii, regions(ss)) | get_ref(ii, regions(ss)));
            S_P = [N1(ss) N2(ss)];
            Start = [ind1_begin(ss) ind2_begin(ss)];
            End = [ind1_end(ss) ind2_end(ss)];
            P_ss = find_pattern(I, S_P, Start, End, B_invalid | ~B_valid);
            % Preserve pattern-to-pattern continuity using the reference
            edge = P_ss(ind1_ref{ss},ind2_ref{ss},:);
            edge_ref = P_best(mod((1:N_ref)-offset1(ss)-1, end)+1,mod((1:N_ref)-offset2(ss)-1, end)+1,:);
%             [~, cshift] = clever_statistics_and_outliers(- edge + 0, -3, 1); % Here -3 reads as NOT 3rd dimension
            [~, cshift] = clever_statistics_and_outliers(- edge + edge_ref, -3, 1); % Here -3 reads as NOT 3rd dimension
            P_ss = bsxfun(@plus, P_ss, cshift);
            % Discard reference pixels added for continuity preservation
            varargout{ss} = P_ss(ind1_wo_ref{ss},ind2_wo_ref{ss},:);
        end
    end

    function [P, B_invalid] = find_pattern(I, S_P, Start, End, B_invalid),
        if nargin < 4, B_invalid = false(size(I)); end
        N_side_1 = S_P(1);
        N_side_2 = S_P(2);
        P = zeros(N_side_1, N_side_2, D);
        ind1 = Start(1):End(1);
        ind2 = Start(2):End(2);
        
        S_truncated = ceil((End(1:2)-Start(1:2)+1)./S_P(1:2)).*S_P(1:2);
        I_truncated = nan(S_truncated); % Preallocate to pad with NaNs once and avoid padarray
        
        sigmas_threshold = SigmasThreshold;
        for cc = 1:D,
            if IgnoreChannels(cc), continue; end
            
            I_channel = double(I(:,:,cc));
            if nargin == 5, I_channel(B_invalid(:,:,cc)) = NaN; end % Exclude common outliers!
            
            % Truncate and pad with NaNs
            I_truncated(ind1-Start(1)+1,ind2-Start(2)+1) = I_channel(ind1,ind2);
            
            % Transform to log-space if requested
            if ~AdditiveMode, I_truncated = log(I_truncated); end
            
            % Reshape to reveal the squares
            I_reshaped = permute(reshape(I_truncated, [N_side_1 S_truncated(1)/N_side_1 N_side_2 S_truncated(2)/N_side_2]), [1 3 2 4]);
            
            % Make rolling window analysis if requested
            if ~RollingWindowAnalysis, extra_dim = [];,
            else,
                [I_reshaped, ind_RWA] = rolling_window_analysis_transformation(I_reshaped, [1 1 0 0], true);
                extra_dim = ndims(I_reshaped);
            end
            
            % Clever mean of the squares (discarding possible outliers that are outside certain distance in sigmas)
            if UseMedian,
                if ~IsFlat,
                    [~, ~, ~, ~, P_cc_offset] = clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*sigmas_threshold); % Extract blockwise average illumination levels
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, ~, ~, ~, P_cc] = clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], sigmas_threshold);
            else,
                if ~IsFlat,
                    [~, P_cc_offset, ~, ~, ~] = clever_statistics_and_outliers(I_reshaped, [1 2 extra_dim], 1.5.*sigmas_threshold); % Extract blockwise average illumination levels
                    I_reshaped = bsxfun(@minus, I_reshaped, P_cc_offset);
                end
                [B_cc, P_cc, ~, ~, ~] = clever_statistics_and_outliers(I_reshaped, [3 4 extra_dim], sigmas_threshold);
            end
            
            P_cc = P_cc - mynanmean(P_cc(:)); % Remove mean value to minimize changes to the original image
            
            % Replace NaNs with linearly interpolated values
            [X, Y] = ndgrid(1:size(P_cc, 1), 1:size(P_cc, 2));
            B_isnan = isnan(P_cc);
            
            try, % Requires R2013a or newer!
                F = scatteredInterpolant(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), 'linear', 'linear');
                P_cc(B_isnan) = F(X(B_isnan), Y(B_isnan));
            catch, % For backward compatibility
                P_cc(B_isnan) = griddata(X(~B_isnan), Y(~B_isnan), P_cc(~B_isnan), X(B_isnan), Y(B_isnan), 'linear');
                P_cc(isnan(P_cc)) = 0; % Set extrapolated regions (= NaNs) to zero
            end

            % Construct boolean map for outliers if requested
            if RollingWindowAnalysis,
                S_B_cc = size(B_cc);
                B_cc = reshape(accumarray(ind_RWA(ind_RWA>0),~B_cc(ind_RWA>0)) == 0, S_B_cc(1:end-1));
            end
            B_cc = reshape(permute(B_cc, [1 3 2 4]), S_truncated);
            if nargout > 1,
                B_invalid(Start(1):Start(1)-1+S_truncated(1),Start(2):Start(2)-1+S_truncated(2),cc) = B_cc;
            end
            
%             if debug,
%                 figure; nanimagesc(P_cc.'); daspect([1 1 1]);
%                 I_reshaped = reshape(permute(I_reshaped, [1 3 2 4]), S_truncated);
%                 I_reshaped(B_cc) = NaN;
%                 figure; nanimagesc(I_reshaped.'); daspect([1 1 1]);
%             end
            P(:,:,cc) = P_cc;
        end
    end
    
    % Please note that this is unable to produce correct pattern for the
    % first and last full rows and columns, because their pattern differ
    % from the middle region. Nor it can correctly produce edge pattern for
    % the aborted Video Stitching images.
    function I_wo_P = remove_pattern(I, P, B_valid, P_TopLeft), % Low memory usage via loops
        I_wo_P = I; % Retain the original image data type!
        
        % Negate the P
        P = -P;
        
        % If multiplicative mode, then transform back to linear-space
        if ~AdditiveMode, P = exp(P-eps); end
        
        % Get sizes
        S_I = size(I); % Size of an image
        S_P = size(P); % Size of a pattern (inverted)
        S_G = ceil(S_I(1:2)./S_P(1:2)); % Size of pattern grid
        
        % Repmat either P or I_wo_P once
        if S_P(3) == 1 && S_I(3) ~= 1,
            P = repmat(P, [1 1 S_I(3)]);
            S_P(3) = S_I(3);
        end
        if S_I(3) == 1 && S_P(3) ~= 1,
            I_wo_P = repmat(I_wo_P, [1 1 S_P(3)]);
            S_I(3) = S_P(3);
        end
        
        % Set pattern range
        if nargin < 3 || isempty(B_valid), B_valid = true(size(I_wo_P)); end
        if nargin < 4 || isempty(P_TopLeft), P_TopLeft = ones(1,2); end
        
        % Repmat TrueBlackColor once (only if used)
        isBlack = all(TrueBlackColor) == 0;
        if ~isBlack,
            Black = bsxfun(@times, double(TrueBlackColor), ones(size(S_P)));
        end
        
        % Shift P once
        [x_P0, y_P0] = deal(1:S_P(1), 1:S_P(2));
        x_P = mod(x_P0-P_TopLeft(1), S_P(1))+1; % Shift indices
        y_P = mod(y_P0-P_TopLeft(2), S_P(2))+1; % Shift indices
        P = P(x_P, y_P, :);
        
        % Preallocate boolean map once
        B_valid_for_P_here = false(size(P));
        B_valid_here = false(size(I_wo_P));
        
        % Remove pattern without memory-intensive repmat
        for x_G = 1:S_G(1),
            % Generate indices in x-direction
            x_I = x_P0 + (x_G-1).*S_P(1);
            
            % Truncate (if partial) to valid indices in x-direction
            B_x = x_I <= S_I(1);
            if any(B_x) == false, continue; end % Skip to next if no valid
            x_P0_valid = x_P0(B_x);
            x_I_valid = x_I(B_x);
            
            for y_G = 1:S_G(2),
                % Generate indices in y-direction
                y_I = y_P0 + (y_G-1).*S_P(2);
                
                % Truncate (if partial) to valid indices in y-direction
                B_y = y_I <= S_I(2);
                if any(B_y) == false, continue; end % Skip to next if no valid
                y_P0_valid = y_P0(B_y);
                y_I_valid = y_I(B_y);
                
                % Generate boolean maps
                B_valid_for_P_here(x_P0_valid,y_P0_valid,:) = B_valid(x_I_valid,y_I_valid,:);
                B_valid_here(x_I_valid,y_I_valid,:) = B_valid_for_P_here(x_P0_valid,y_P0_valid,:);
                
                % Remove pattern piece-by-piece
                I_here = double(I(B_valid_here));
                P_here = P(B_valid_for_P_here);
                if AdditiveMode,
                    I_wo_P(B_valid_here) = I_here + P_here;
                else, % Multiplicative mode
                    if isBlack, I_wo_P(B_valid_here) = I_here .* P_here;
                    else,
                        Black_here = Black(B_valid_for_P_here);
                        I_wo_P(B_valid_here) = (I_here - Black_here) .* P_here + Black_here;
                    end
                end
                
                % Restore boolean maps
                B_valid_for_P_here(B_valid_for_P_here) = false;
                B_valid_here(B_valid_here) = false;
            end
        end
    end
end
