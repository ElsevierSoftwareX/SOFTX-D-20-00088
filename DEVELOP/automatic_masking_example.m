exporting = false;

% Load files
File = 'automatic_masking_example.wip';
if exist('O_wip', 'var') ~= 1 || ~strcmp(O_wip.Tree.File, which(File)), % Load the specified project only if it has not been already loaded
    [O_wid, O_wip, O_wid_HtmlNames] = wip.read(File, '-all', '-ForceSpectralUnit', '(rel. 1/cm)', '-Manager', {'-Type', 'TDGraph', '-SubType', 'Image'});
    O = O_wid(1);
    
    % Load their Info only once
    O_Info = O.Info;
    
    % Peaks of interest
    Range_0 = [-25 25]; % Rayleigh-peak
    Range_Si = [500 550]; % Silicon main peak
    Range_G = [1540 1640]; % Graphene G-peak
    Range_2D = [2600 2800]; % Graphene 2D-peak
    
    % First fit Gaussian to Rayleigh-peak in order to find instrument-induced Fwhm_G (needed for Voigtian-fitting)
    [O_0, I_0, Pos_0, Fwhm_0, I0_0, R2_0] = O.filter_gaussian(Range_0); % Gauss filtering after removal of linear background (using filter_bg)
    [O_Si, I_Si, Pos_Si, Fwhm_Si, I0_Si, R2_Si] = O.filter_lorentzian(Range_Si); % Lorentz filtering after removal of linear background (using filter_bg)
    [O_G, I_G, Pos_G, Fwhm_G, I0_G, R2_G] = O.filter_lorentzian(Range_G); % Lorentz filtering after removal of linear background (using filter_bg)
    [O_2D, I_2D, Pos_2D, Fwhm_2D, I0_2D, R2_2D] = O.filter_lorentzian(Range_2D); % Lorentz filtering after removal of linear background (using filter_bg)
    
    % Cleanup bad fitting results
    B_Si_valid = mask_bad_results_and_noise(O.Data, O_Info.Graph, Range_Si, I_Si, Pos_Si);
    B_Si_valid = ~data_true_and_nan_collective_hole_reduction(~B_Si_valid); % Reduce one-pixel noise
    B_Si_valid = data_true_and_nan_collective_hole_reduction(B_Si_valid); % Reduce one-pixel noise
    
    B_G_valid = mask_bad_results_and_noise(O.Data, O_Info.Graph, Range_G, I_G, Pos_G);
    B_G_valid = ~data_true_and_nan_collective_hole_reduction(~B_G_valid); % Reduce one-pixel noise
    B_G_valid = data_true_and_nan_collective_hole_reduction(B_G_valid); % Reduce one-pixel noise
    
    B_2D_valid = mask_bad_results_and_noise(O.Data, O_Info.Graph, Range_2D, I_2D, Pos_2D);
    B_2D_valid = ~data_true_and_nan_collective_hole_reduction(~B_2D_valid); % Reduce one-pixel noise
    B_2D_valid = data_true_and_nan_collective_hole_reduction(B_2D_valid); % Reduce one-pixel noise
    
    % Utilize combined knowledge of the invalid regions
    B = ~data_true_and_nan_collective_hole_reduction(~B_G_valid, ~B_2D_valid);
end

% Uncomment one of the following to inspect the individual autogenerated masks
% figure; imagesc(B_Si_valid.'); % Should be all true for Si-peak
% figure; imagesc(B_G_valid.'); % Should be all true only on the graphene flake
% figure; imagesc(B_2D_valid.'); % Should be all true only on the graphene flake

close all;

variables = {'I_Si', 'Pos_Si', 'I_G', 'Pos_G', 'I_2D', 'Pos_2D'};
mask_usages = [false false true true true true];
defaults = [0 nan 0 nan 0 nan];
ymins = [0 nan 0 nan 0 nan];
titles = {'I(Si)', 'Pos(Si)', 'I(G)', 'Pos(G)', 'I(2D)', 'Pos(2D)'};
units = {'(a.u.)', '(rel. 1/cm)', '(a.u.)', '(rel. 1/cm)', '(a.u.)', '(rel. 1/cm)'};

for ii = 1:numel(variables),
    var_ii = eval(variables{ii}); % Use eval to allow looping the variables!
    if mask_usages(ii),
        var_ii(~B) = defaults(ii); % Discard data that was fitted to too low std or too noisy
    end

    fig = figure;
    fig.Units = 'centimeters';
    fig.Position = [fig.Position(1:2) 16 10];
    fig.Color = [1 1 1];

    clever_nanimagesc(var_ii.');
    daspect([1 O_Info.XLength/O_Info.YLength 1]);

    % Choose perceptually uniform colormap (https://bids.github.io/colormap/)
    colormap(perceptually_uniform_colormap('inferno')); % Possible options are 'magma', 'inferno', 'plasma', 'viridis', 'cividis', 'graymagma', 'grayinferno', 'grayplasma', 'grayviridis', 'graycividis', 'gray'

    h_cb = colorbar('Location', 'EastOutside');
    h_cb.Label.String = units{ii};
    
    if ~isnan(ymins(ii)),
        ylim_ii = get(gca, 'CLim');
        ylim_ii(1) = ymins(ii);
        set(gca, 'CLim', ylim_ii);
    end
    
    title(titles{ii});
    
    set(gca, 'XTick', [], 'XTickLabel', '', 'YTickLabel', '', 'YTick', []);
    box on;
    
    xlabel(sprintf('%.3g um', size(var_ii, 1)./size(O.Data, 1).*O_Info.XLength));
    ylabel(sprintf('%.3g um', size(var_ii, 2)./size(O.Data, 2).*O_Info.YLength));
    
    % Save figure
    if exporting,
        export_opt = {'-r300', ... % Dots Per Inch (DPI), ...
        '-nofontswap', ... % Preserves original fonts for vector formats
        '-q101'}; % Quality: q > 100 ensures lossless compression!
        export_fig(sprintf('1_%s.png', variables{ii}), fig, export_opt{:});
    end
end
